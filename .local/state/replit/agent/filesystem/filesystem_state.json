{"file_contents":{"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1))\",\n          \"2\": \"hsl(var(--chart-2))\",\n          \"3\": \"hsl(var(--chart-3))\",\n          \"4\": \"hsl(var(--chart-4))\",\n          \"5\": \"hsl(var(--chart-5))\",\n        },\n        sidebar: {\n          DEFAULT: \"hsl(var(--sidebar-background))\",\n          foreground: \"hsl(var(--sidebar-foreground))\",\n          primary: \"hsl(var(--sidebar-primary))\",\n          \"primary-foreground\": \"hsl(var(--sidebar-primary-foreground))\",\n          accent: \"hsl(var(--sidebar-accent))\",\n          \"accent-foreground\": \"hsl(var(--sidebar-accent-foreground))\",\n          border: \"hsl(var(--sidebar-border))\",\n          ring: \"hsl(var(--sidebar-ring))\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":2787},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path, { dirname } from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { fileURLToPath } from \"url\";\nimport glsl from \"vite-plugin-glsl\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    glsl(),\n  ],\n  base: \"/\",\n  server: {\n    host: \"0.0.0.0\",\n    port: 5000,\n    strictPort: true,\n    allowedHosts: true,\n    hmr: {\n      clientPort: 443,\n      protocol: 'wss'\n    }\n  },\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(__dirname, \"shared\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: \"dist\",\n    emptyOutDir: true,\n  },\n  assetsInclude: [\"**/*.gltf\", \"**/*.glb\", \"**/*.mp3\", \"**/*.ogg\", \"**/*.wav\"],\n});","size_bytes":961},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"â€¦\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 5000\n  // this serves both the API and the client\n  const port = 5000;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();\n","size_bytes":1871},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // put application routes here\n  // prefix all routes with /api\n\n  // use storage to perform CRUD operations on the storage interface\n  // e.g. storage.insertUser(user) or storage.getUserByUsername(username)\n\n  const httpServer = createServer(app);\n\n  return httpServer;\n}\n","size_bytes":473},"server/storage.ts":{"content":"import { users, type User, type InsertUser } from \"@shared/schema\";\n\n// modify the interface with any CRUD methods\n// you might need\n\nexport interface IStorage {\n  getUser(id: number): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n}\n\nexport class MemStorage implements IStorage {\n  private users: Map<number, User>;\n  currentId: number;\n\n  constructor() {\n    this.users = new Map();\n    this.currentId = 1;\n  }\n\n  async getUser(id: number): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    return Array.from(this.users.values()).find(\n      (user) => user.username === username,\n    );\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const id = this.currentId++;\n    const user: User = { ...insertUser, id };\n    this.users.set(id, user);\n    return user;\n  }\n}\n\nexport const storage = new MemStorage();\n","size_bytes":1012},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path, { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    host: '0.0.0.0',\n    allowedHosts: 'all',\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        __dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2396},"shared/schema.ts":{"content":"import { pgTable, text, serial, integer, boolean } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  username: text(\"username\").notNull().unique(),\n  password: text(\"password\").notNull(),\n});\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  username: true,\n  password: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\n","size_bytes":533},"client/src/App.tsx":{"content":"import { BrowserRouter, Routes, Route, Navigate } from \"react-router-dom\";\nimport Home from \"./pages/Home\";\nimport ClassicMode from \"./pages/ClassicMode\";\nimport BaseReactionMode from \"./pages/BaseReactionMode\";\nimport NotFound from \"./pages/not-found\";\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/chain-reaction\" element={<ClassicMode />} />\n        <Route path=\"/base-reaction\" element={<BaseReactionMode />} />\n        <Route path=\"/tutorial\" element={<Navigate to=\"/\" replace />} />\n        <Route path=\"/tutorial/:mode\" element={<Navigate to=\"/\" replace />} />\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n","size_bytes":769},"client/src/index.css":{"content":"@import './assets/fonts.css';\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer utilities {\n  .shadow-glow {\n    box-shadow: 0 0 15px 2px rgba(255, 255, 255, 0.3);\n    transition: box-shadow 0.3s ease;\n  }\n  \n  .hover\\:shadow-glow:hover {\n    box-shadow: 0 0 15px 2px rgba(255, 255, 255, 0.3);\n  }\n}\n\n/* HQ Base glow pulse animation */\n@keyframes pulse {\n  0%, 100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n  50% {\n    opacity: 0.7;\n    transform: scale(1.05);\n  }\n}\n\n/* Override base styles for the typewriter font */\n@layer base {\n  html {\n    font-family: var(--font-arista), system-ui, sans-serif;\n  }\n  \n  * {\n    @apply border-border;\n  }\n\n  body {\n    @apply font-sans antialiased bg-gray-900 text-white;\n    margin: 0;\n    padding: 0;\n    width: 100vw;\n    height: 100vh;\n    overflow-x: hidden;\n  }\n}\n\n#root {\n  width: 100%;\n  height: 100%;\n  position: fixed;\n}\n\ncanvas {\n  width: 100% !important;\n  height: 100% !important;\n  touch-action: none;\n}","size_bytes":981},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","size_bytes":157},"client/src/assets/fonts.css":{"content":"/* Game Font */\n:root {\n  --font-game: 'Menlo', monospace;\n  --font-american-typewriter: 'Menlo', monospace; /* Keeping for backward compatibility */\n}\n\nbody {\n  font-family: var(--font-game);\n}\n\nh1, h2, h3, h4, h5, h6, button, .font-typewriter {\n  font-family: var(--font-game);\n}","size_bytes":281},"client/src/hooks/use-is-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","size_bytes":565},"client/src/lib/aiPlayer.ts":{"content":"import { PLAYER } from './constants';\nimport { GridCell, HQCell, PowerUpCell } from './stores/useChainReaction';\nimport { calculateCriticalMass, isAdjacentTo } from './gameUtils';\n\nexport enum AI_STRATEGY {\n  SMART = 'smart'\n}\n\ninterface AIMove {\n  row: number;\n  col: number;\n  score: number;\n}\n\ninterface GameState {\n  grid: GridCell[][];\n  currentPlayer: PLAYER;\n  isBaseMode: boolean;\n  hqs?: HQCell[];\n  powerUps?: PowerUpCell[];\n}\n\ninterface StrategicEvaluation {\n  aggressiveScore: number;     // How much damage this move can cause to enemies\n  defensiveScore: number;      // How well this move protects our base\n  powerUpScore: number;        // Value of capturing power-ups\n  chainReactionScore: number;  // Potential for large chain reactions\n  territoryScore: number;      // Expanding our controlled territory\n  baseThreatScore: number;     // How much this threatens enemy bases\n}\n\n// AI Personality traits that change each game - MUCH MORE EXTREME\ninterface AIPersonality {\n  aggressiveness: number;      // 0.2-2.5 (how much AI prioritizes attacks)\n  defensiveness: number;       // 0.2-2.5 (how much AI prioritizes defense)\n  riskTaking: number;          // 0.2-2.5 (how much AI takes risky moves)\n  powerUpHunting: number;      // 0.8-3.0 (how much AI chases power-ups)\n  territorialness: number;     // 0.2-2.5 (how much AI values territory)\n  cornerPreference: number;    // 0.1-2.0 (preference for corners, can be very low to prevent obsession)\n  spreadTendency: number;      // 0.2-2.5 (tendency to spread vs consolidate)\n}\n\n/**\n * Determines if a move is valid according to game rules\n */\nexport const isValidMoveForAI = (\n  grid: GridCell[][],\n  row: number,\n  col: number,\n  currentPlayer: PLAYER,\n  isBaseMode: boolean,\n  hqs?: HQCell[]\n): boolean => {\n  // Cell is out of bounds\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n    return false;\n  }\n\n  const cell = grid[row][col];\n  \n  // Check if this is an HQ cell (cannot place on HQ cells)\n  if (isBaseMode && hqs && hqs.some(hq => hq.row === row && hq.col === col)) {\n    return false;\n  }\n\n  // Classic Mode: Cell is empty or already owned by the current player\n  if (!isBaseMode) {\n    return cell.player === null || cell.player === currentPlayer;\n  }\n  \n  // Base Reaction Mode\n  \n  // Cell already has atoms and is owned by another player\n  if (cell.player !== null && cell.player !== currentPlayer) {\n    return false;\n  }\n  \n  // Check if this is the first move (player can only place on their row or column)\n  if (hqs) {\n    // Find the current player's HQ\n    const playerHQ = hqs.find(hq => hq.player === currentPlayer);\n    \n    if (playerHQ) {\n      // Check if this is the first move\n      let hasPlayerDots = false;\n      for (let r = 0; r < grid.length; r++) {\n        for (let c = 0; c < grid[r].length; c++) {\n          if (grid[r][c].player === currentPlayer && grid[r][c].atoms > 0) {\n            hasPlayerDots = true;\n            break;\n          }\n        }\n        if (hasPlayerDots) break;\n      }\n      \n      // First move - can only place on player's row or column\n      if (!hasPlayerDots) {\n        // Can only place on the row or column of the HQ\n        return row === playerHQ.row || col === playerHQ.col;\n      }\n      \n      // After first move - can place adjacent to existing dots or near HQ\n      let hasAdjacentDot = false;\n      \n      // Check if adjacent to player's HQ (3x3 area around HQ)\n      const nearHQ = Math.abs(row - playerHQ.row) <= 1 && Math.abs(col - playerHQ.col) <= 1;\n      \n      // Check if adjacent to any existing player dot\n      for (let r = 0; r < grid.length; r++) {\n        for (let c = 0; c < grid[r].length; c++) {\n          if (grid[r][c].player === currentPlayer && grid[r][c].atoms > 0) {\n            if (isAdjacentTo(row, col, r, c)) {\n              hasAdjacentDot = true;\n              break;\n            }\n          }\n        }\n        if (hasAdjacentDot) break;\n      }\n      \n      return nearHQ || hasAdjacentDot;\n    }\n  }\n  \n  return true;\n};\n\n/**\n * Get neighbors for AI calculations\n */\nconst getNeighborsForAI = (row: number, col: number, rows: number, cols: number) => {\n  const neighbors = [];\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right\n  \n  for (const [dr, dc] of directions) {\n    const nr = row + dr;\n    const nc = col + dc;\n    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\n      neighbors.push({ nr, nc });\n    }\n  }\n  \n  return neighbors;\n};\n\n/**\n * Advanced strategic evaluation for aggressive and smart AI\n */\nconst evaluateStrategicMove = (\n  grid: GridCell[][],\n  row: number,\n  col: number,\n  currentPlayer: PLAYER,\n  gameState: GameState\n): StrategicEvaluation => {\n  const evaluation: StrategicEvaluation = {\n    aggressiveScore: 0,\n    defensiveScore: 0,\n    powerUpScore: 0,\n    chainReactionScore: 0,\n    territoryScore: 0,\n    baseThreatScore: 0\n  };\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const cell = grid[row][col];\n  const criticalMass = calculateCriticalMass(row, col, rows, cols);\n\n  // 1. POWER-UP SCORING - Only in Base Mode (no power-ups in chain reaction)\n  if (gameState.isBaseMode && gameState.powerUps) {\n    const powerUpAtPosition = gameState.powerUps.find(pu => pu.row === row && pu.col === col);\n    if (powerUpAtPosition) {\n        // Power-ups are EXTREMELY valuable - AI should prioritize these highly\n        evaluation.powerUpScore = powerUpAtPosition.type === 'diamond' ? 150 : 150; // Much higher values\n    }\n\n    // Strong bonus for being near power-ups - AI should chase them aggressively  \n    gameState.powerUps.forEach(powerUp => {\n      const distanceToPowerUp = Math.abs(powerUp.row - row) + Math.abs(powerUp.col - col);\n      if (distanceToPowerUp <= 3) {\n        evaluation.powerUpScore += (4 - distanceToPowerUp) * 25; // Much stronger proximity bonus\n      }\n    });\n  }\n\n  // 2. POSITION SCORING - Different strategies for different game modes\n  const isCorner = (row === 0 || row === rows - 1) && (col === 0 || col === cols - 1);\n  const isEdge = row === 0 || row === rows - 1 || col === 0 || col === cols - 1;\n  \n  if (!gameState.isBaseMode) {\n    // CLASSIC MODE: Corners are valuable but not obsessively so, with randomness\n    const cornerBonus = 20 + Math.random() * 20; // 15-40 random bonus\n    const edgeBonus = 8 + Math.random() * 10;   // 8-18 random bonus\n    const centerBonus = 2 + Math.random() * 8;  // 2-10 random bonus\n    \n    if (isCorner) {\n      evaluation.territoryScore += cornerBonus;\n    } else if (isEdge) {\n      evaluation.territoryScore += edgeBonus;\n    } else {\n      evaluation.territoryScore += centerBonus;\n    }\n    \n    // In classic mode, avoid placing next to enemy cells initially (with some randomness)\n    const neighbors = getNeighborsForAI(row, col, rows, cols);\n    let enemyNeighborPenalty = 0;\n    neighbors.forEach(({nr, nc}) => {\n      const neighborCell = grid[nr][nc];\n      if (neighborCell.player && neighborCell.player !== currentPlayer) {\n        enemyNeighborPenalty += 10 + Math.random() * 10; // 10-20 random penalty\n      }\n    });\n    evaluation.aggressiveScore -= enemyNeighborPenalty;\n    \n    // Encourage spreading to different areas in classic mode\n    let isolationBonus = 0;\n    let hasOwnNeighbor = false;\n    neighbors.forEach(({nr, nc}) => {\n      const neighborCell = grid[nr][nc];\n      if (neighborCell.player === currentPlayer) {\n        hasOwnNeighbor = true;\n      }\n    });\n    if (!hasOwnNeighbor) {\n      isolationBonus += 8 + Math.random() * 12; // 8-20 random bonus for spreading\n    }\n    evaluation.territoryScore += isolationBonus;\n  } else {\n    // BASE MODE: Corners and edges are much less important, focus on center\n    const cornerBonus = 1 + Math.random() * 6;  // 2-8 low corner value\n    const edgeBonus = 3 + Math.random() * 6;    // 1-5 low edge value  \n    const centerBonus = 1 + Math.random() * 6;  // 6-14 higher center value\n    \n    if (isCorner) {\n      evaluation.territoryScore += cornerBonus;\n    } else if (isEdge) {\n      evaluation.territoryScore += edgeBonus;\n    } else {\n      evaluation.territoryScore += centerBonus;\n    }\n  }\n\n  // 3. AGGRESSIVE SCORING - Prioritize moves that capture enemy territory\n  let enemyCaptureCount = 0;\n  let enemyProximityScore = 0;\n  \n  // Check how many enemy cells this move would affect if it explodes\n  if (cell.atoms + 1 >= criticalMass) {\n    const neighbors = getNeighborsForAI(row, col, rows, cols);\n    neighbors.forEach(({nr, nc}) => {\n      const neighborCell = grid[nr][nc];\n      if (neighborCell.player && neighborCell.player !== currentPlayer) {\n        enemyCaptureCount += neighborCell.atoms + 1; // Potential atoms to capture\n        evaluation.aggressiveScore += 15 * neighborCell.atoms; // More atoms = higher value\n      }\n    });\n  }\n\n  // Check proximity to enemy positions for future aggressive moves (only in base mode)\n  if (gameState.isBaseMode) {\n    for (let r = Math.max(0, row - 2); r <= Math.min(rows - 1, row + 2); r++) {\n      for (let c = Math.max(0, col - 2); c <= Math.min(cols - 1, col + 2); c++) {\n        const targetCell = grid[r][c];\n        if (targetCell.player && targetCell.player !== currentPlayer) {\n          const distance = Math.abs(r - row) + Math.abs(c - col);\n          enemyProximityScore += (3 - distance) * targetCell.atoms * 2; // Proximity bonus for base mode\n        }\n      }\n    }\n  }\n  evaluation.aggressiveScore += enemyProximityScore;\n\n  // 4. BASE THREAT SCORING - Prioritize moves that threaten enemy bases\n  if (gameState.isBaseMode && gameState.hqs) {\n    gameState.hqs.forEach(hq => {\n      if (hq.player !== currentPlayer) {\n        const distanceToHQ = Math.abs(hq.row - row) + Math.abs(hq.col - col);\n        if (distanceToHQ <= 3) {\n          evaluation.baseThreatScore += (4 - distanceToHQ) * 20; // Closer to enemy HQ = much better\n          \n          // Extra bonus for moves that could explode near enemy HQ\n          if (cell.atoms + 1 >= criticalMass && distanceToHQ <= 2) {\n            evaluation.baseThreatScore += 40;\n          }\n        }\n      }\n    });\n  }\n\n  // 5. DEFENSIVE SCORING - Much stronger base defense\n  if (gameState.isBaseMode && gameState.hqs) {\n    const ourHQ = gameState.hqs.find(hq => hq.player === currentPlayer);\n    if (ourHQ) {\n      const distanceToOurHQ = Math.abs(ourHQ.row - row) + Math.abs(ourHQ.col - col);\n      \n      // Check for enemy threats near our base - extended range\n      let enemyThreatNearBase = 0;\n      let criticalThreats = 0;\n      \n      for (let r = Math.max(0, ourHQ.row - 3); r <= Math.min(rows - 1, ourHQ.row + 3); r++) {\n        for (let c = Math.max(0, ourHQ.col - 3); c <= Math.min(cols - 1, ourHQ.col + 3); c++) {\n          const threatCell = grid[r][c];\n          if (threatCell.player && threatCell.player !== currentPlayer) {\n            const threatDistance = Math.abs(r - ourHQ.row) + Math.abs(c - ourHQ.col);\n            const threatMultiplier = Math.max(1, 4 - threatDistance);\n            enemyThreatNearBase += threatCell.atoms * threatMultiplier * 8; // Much higher threat weighting\n            \n            // Critical threats are very close and have many atoms\n            if (threatDistance <= 2 && threatCell.atoms >= 2) {\n              criticalThreats += threatCell.atoms * 15;\n            }\n          }\n        }\n      }\n      \n      // Much stronger defensive response\n      if (enemyThreatNearBase > 0) {\n        const defensiveUrgency = Math.min(distanceToOurHQ, 4);\n        evaluation.defensiveScore += enemyThreatNearBase * (5 - defensiveUrgency) * 2; // Double the defensive priority\n        \n        // Critical threat response - highest priority\n        if (criticalThreats > 0 && distanceToOurHQ <= 3) {\n          evaluation.defensiveScore += criticalThreats * 3;\n        }\n        \n        // Extra bonus for converting enemy cells near our base\n        if (cell.player && cell.player !== currentPlayer) {\n          evaluation.defensiveScore += 40; // Increased conversion bonus\n        }\n        \n        // Bonus for blocking enemy expansion towards our base\n        if (distanceToOurHQ <= 2) {\n          evaluation.defensiveScore += 30;\n        }\n      }\n      \n      // When base health is low, increase defensive priority even more\n      if (ourHQ.health <= 2) {\n        evaluation.defensiveScore *= 2; // Double all defensive scores when health is critical\n      }\n    }\n  }\n\n  // 6. CHAIN REACTION SCORING - Look for massive chain reaction potential\n  const chainPotential = calculateChainReactionPotential(grid, row, col, currentPlayer);\n  evaluation.chainReactionScore = chainPotential * 10;\n\n  return evaluation;\n};\n\n/**\n * Calculate potential for chain reactions\n */\nconst calculateChainReactionPotential = (\n  grid: GridCell[][],\n  row: number,\n  col: number,\n  currentPlayer: PLAYER\n): number => {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let chainPotential = 0;\n\n  // Simulate what happens if we place a dot here\n  const simulatedGrid = grid.map(row => row.map(cell => ({ ...cell })));\n  const cell = simulatedGrid[row][col];\n  cell.atoms++;\n  cell.player = currentPlayer;\n\n  const criticalMass = calculateCriticalMass(row, col, rows, cols);\n  if (cell.atoms >= criticalMass) {\n    // This cell will explode, check how many neighboring cells might also explode\n    const neighbors = getNeighborsForAI(row, col, rows, cols);\n    neighbors.forEach(({nr, nc}) => {\n      const neighborCell = simulatedGrid[nr][nc];\n      const neighborCritical = calculateCriticalMass(nr, nc, rows, cols);\n      \n      if (neighborCell.atoms + 1 >= neighborCritical) {\n        chainPotential += 5; // Each potential chain reaction cell\n        \n        // Look one level deeper\n        const secondNeighbors = getNeighborsForAI(nr, nc, rows, cols);\n        secondNeighbors.forEach(({nr: nnr, nc: nnc}) => {\n          const secondCell = simulatedGrid[nnr][nnc];\n          const secondCritical = calculateCriticalMass(nnr, nnc, rows, cols);\n          if (secondCell.atoms + 1 >= secondCritical) {\n            chainPotential += 2;\n          }\n        });\n      }\n    });\n  }\n\n  return chainPotential;\n};\n\n/**\n * Generates a random AI personality for each game to prevent predictable behavior\n */\nfunction generateAIPersonality(): AIPersonality {\n  return {\n    aggressiveness: 0.2 + Math.random() * 2.3,      // 0.2-2.5 (MUCH MORE EXTREME)\n    defensiveness: 0.2 + Math.random() * 2.3,       // 0.2-2.5 (MUCH MORE EXTREME)\n    riskTaking: 0.2 + Math.random() * 2.3,          // 0.2-2.5 (MUCH MORE EXTREME)\n    powerUpHunting: 0.8 + Math.random() * 2.2,      // 0.8-3.0 (Very high power-up chasing)\n    territorialness: 0.2 + Math.random() * 2.3,     // 0.2-2.5 (MUCH MORE EXTREME)\n    cornerPreference: 0.1 + Math.random() * 1.9,    // 0.1-2.0 (MUCH MORE EXTREME, can be very low)\n    spreadTendency: 0.2 + Math.random() * 2.3       // 0.2-2.5 (MUCH MORE EXTREME)\n  };\n}\n\n/**\n * PERSONALITY-BASED AI SYSTEM\n * Each AI has unique personality traits that make it behave differently\n */\nclass PersonalityBasedAI {\n  private personalities: Map<PLAYER, AIPersonality> = new Map();\n  \n  getPersonality(player: PLAYER): AIPersonality {\n    if (!this.personalities.has(player)) {\n      this.personalities.set(player, generateAIPersonality());\n      console.log(`ðŸŽ­ Generated new personality for ${player}:`, this.personalities.get(player));\n    }\n    return this.personalities.get(player)!;\n  }\n\n  // Reset personalities for new game\n  resetPersonalities(): void {\n    this.personalities.clear();\n  }\n\n  evaluateMove(\n    grid: GridCell[][],\n    row: number,\n    col: number,\n    currentPlayer: PLAYER,\n    gameState: GameState\n  ): number {\n    const evaluation = evaluateStrategicMove(grid, row, col, currentPlayer, gameState);\n    const personality = this.getPersonality(currentPlayer);\n    \n    // Calculate base score with personality-influenced priorities\n    let baseScore = 0;\n    \n    // Apply personality traits to scoring\n    baseScore += evaluation.powerUpScore * personality.powerUpHunting * 1.8;\n    baseScore += evaluation.territoryScore * personality.territorialness * personality.cornerPreference * 0.8;\n    baseScore += evaluation.defensiveScore * personality.defensiveness * 2.0;\n    baseScore += evaluation.aggressiveScore * personality.aggressiveness * 1.5;\n    baseScore += evaluation.baseThreatScore * personality.aggressiveness * personality.riskTaking * 1.2;\n    baseScore += evaluation.chainReactionScore * personality.riskTaking * 1.3;\n    \n    // Add significant randomness based on risk-taking personality\n    const baseRandomness = personality.riskTaking * 0.3; // 0.15-0.45\n    const randomness = (Math.random() - 0.5) * 2 * baseRandomness;\n    baseScore += randomness * Math.max(15, Math.abs(baseScore) * 0.2);\n    \n    // Additional chaos factor to prevent identical games\n    const chaosBonus = (Math.random() - 0.5) * 25 * personality.riskTaking;\n    baseScore += chaosBonus;\n    \n    return baseScore;\n  }\n\n  getBestMove(\n    grid: GridCell[][],\n    currentPlayer: PLAYER,\n    isBaseMode: boolean,\n    hqs?: HQCell[],\n    powerUps?: PowerUpCell[]\n  ): AIMove | null {\n    const personality = this.getPersonality(currentPlayer);\n    const gameState: GameState = {\n      grid,\n      currentPlayer,\n      isBaseMode,\n      hqs,\n      powerUps\n    };\n\n    const rows = grid.length;\n    const cols = grid[0].length;\n    const validMoves: AIMove[] = [];\n\n    // Generate all valid moves\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        if (isValidMoveForAI(grid, row, col, currentPlayer, isBaseMode, hqs)) {\n          const score = this.evaluateMove(grid, row, col, currentPlayer, gameState);\n          validMoves.push({ row, col, score });\n        }\n      }\n    }\n\n    if (validMoves.length === 0) {\n      return null;\n    }\n\n    // Sort moves by score (highest first)\n    validMoves.sort((a, b) => b.score - a.score);\n\n    // Use personality to determine move selection randomness\n    const selectionRandomness = personality.riskTaking * 0.4; // 0.2-0.6\n    const topMoves = Math.max(1, Math.ceil(validMoves.length * (0.1 + selectionRandomness)));\n    const bestMoveIndex = Math.floor(Math.random() * Math.min(topMoves, validMoves.length));\n\n    const bestMove = validMoves[bestMoveIndex];\n    \n    console.log(`ðŸŽ­ AI ${currentPlayer} (aggr:${personality.aggressiveness.toFixed(1)}, def:${personality.defensiveness.toFixed(1)}, risk:${personality.riskTaking.toFixed(1)}) chose (${bestMove.row},${bestMove.col}) from top ${topMoves} moves`);\n    \n    return bestMove;\n  }\n}\n\n// Global AI instance\nconst personalityAI = new PersonalityBasedAI();\n\n// Function to reset AI personalities for new games\nexport const resetAIPersonalities = () => {\n  personalityAI.resetPersonalities();\n};\n\n/**\n * Main entry point for AI move calculation\n */\nexport const getAIMove = (\n  grid: GridCell[][],\n  currentPlayer: PLAYER,\n  isBaseMode: boolean,\n  hqs?: HQCell[],\n  strategy: AI_STRATEGY = AI_STRATEGY.SMART,\n  powerUps?: PowerUpCell[]\n): AIMove | null => {\n  console.log(`ðŸŽ¯ AI ${currentPlayer} starting move calculation with personality-based strategy`);\n  \n  try {\n    const move = personalityAI.getBestMove(grid, currentPlayer, isBaseMode, hqs, powerUps);\n    \n    if (move) {\n      console.log(`âœ… AI ${currentPlayer} selected move: (${move.row}, ${move.col}) with score ${move.score.toFixed(1)}`);\n    } else {\n      console.warn(`âŒ AI ${currentPlayer} could not find a valid move`);\n    }\n    \n    return move;\n  } catch (error) {\n    console.error(`ðŸ’¥ AI ${currentPlayer} error:`, error);\n    return null;\n  }\n};","size_bytes":19625},"client/src/lib/constants.ts":{"content":"export enum PLAYER {\n  RED = \"red\",\n  BLUE = \"blue\",\n  VIOLET = \"violet\",\n  BLACK = \"black\"\n}\n\n// Colors as requested:\n// BLUE: (55, 114, 255) - royal blue\n// RED: (223, 41, 53) - bright red\n// BLACK: (8, 7, 8) - near black\n// YELLOW: (253, 202, 64) - golden yellow\n\nexport const PLAYER_COLORS = {\n  [PLAYER.BLUE]: \"rgb(55, 114, 255)\",   // Royal blue\n  [PLAYER.RED]: \"rgb(223, 41, 53)\",     // Bright red\n  [PLAYER.BLACK]: \"rgb(8, 7, 8)\",      // Black\n  [PLAYER.VIOLET]: \"rgb(255, 115, 0)\"  // Violet purple\n};\n\nexport const PLAYER_BG_COLORS = {\n  [PLAYER.BLUE]: \"rgb(27, 57, 128)\",    // Darker royal blue\n  [PLAYER.RED]: \"rgb(112, 20, 26)\",     // Darker bright red\n  [PLAYER.BLACK]: \"rgb(10, 10, 10)\",    // Darker black\n  [PLAYER.VIOLET]: \"rgb(130, 58, 0)\"   // Darker violet purple\n};\n\nexport const CELL_SIZE = 60;\nexport const DOT_SIZE = 15;\nexport const DOT_MARGIN = 5;\n\nexport const DOT_POSITIONS = {\n  1: [{ x: 0, y: 0 }], // Center\n  2: [{ x: -10, y: 0 }, { x: 10, y: 0 }], // Horizontal\n  3: [{ x: 0, y: -10 }, { x: -10, y: 10 }, { x: 10, y: 10 }], // Triangle\n  4: [{ x: -10, y: -10 }, { x: 10, y: -10 }, { x: -10, y: 10 }, { x: 10, y: 10 }], // Square\n};\n\nexport const ANIMATION_DURATION = 300; // ms (exactly 0.3 seconds)\n","size_bytes":1238},"client/src/lib/gameUtils.ts":{"content":"import { PLAYER, PLAYER_COLORS, DOT_POSITIONS } from \"./constants\";\nimport type { GridCell } from \"./stores/useChainReaction\";\n\n// Calculate the critical mass of a cell based on its position\nexport const calculateCriticalMass = (\n  row: number,\n  col: number,\n  rows: number,\n  cols: number\n): number => {\n  // Corner cells (2 neighbors)\n  if (\n    (row === 0 && col === 0) ||\n    (row === 0 && col === cols - 1) ||\n    (row === rows - 1 && col === 0) ||\n    (row === rows - 1 && col === cols - 1)\n  ) {\n    return 2;\n  }\n\n  // Edge cells (3 neighbors)\n  if (row === 0 || row === rows - 1 || col === 0 || col === cols - 1) {\n    return 3;\n  }\n\n  // Center cells (4 neighbors)\n  return 4;\n};\n\n// Get positions for dots in a cell based on the number of dots\nexport const getDotPositions = (\n  atoms: number,\n  cellSize: number,\n  dotSize: number\n): { x: number; y: number }[] => {\n  const positions = DOT_POSITIONS[atoms as keyof typeof DOT_POSITIONS];\n  \n  if (!positions) {\n    // If we don't have a specific layout, create a circular pattern\n    const radius = (cellSize - dotSize * 2) / 3;\n    const angleStep = (2 * Math.PI) / atoms;\n    \n    return Array(atoms)\n      .fill(0)\n      .map((_, i) => {\n        const angle = i * angleStep;\n        return {\n          x: Math.cos(angle) * radius,\n          y: Math.sin(angle) * radius,\n        };\n      });\n  }\n  \n  return positions;\n};\n\n// Check if a grid cell is about to explode (at critical mass - 1)\nexport const isAboutToExplode = (\n  cell: GridCell,\n  row: number,\n  col: number,\n  rows: number,\n  cols: number\n): boolean => {\n  const criticalMass = calculateCriticalMass(row, col, rows, cols);\n  return cell.atoms === criticalMass - 1;\n};\n\n// Generate a random offset for dot animation\nexport const randomOffset = (range: number): number => {\n  return (Math.random() - 0.5) * range;\n};\n\n// Check if a cell is adjacent (including diagonally) to another cell\nexport const isAdjacentTo = (row1: number, col1: number, row2: number, col2: number): boolean => {\n  return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1;\n};\n\n// Calculate if a player has won in classic mode\nexport const checkClassicWinner = (grid: GridCell[][]): PLAYER | null => {\n  const players = new Set<PLAYER>();\n  \n  // Collect all players with atoms on the board\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      const cell = grid[row][col];\n      if (cell.player) {\n        players.add(cell.player);\n      }\n    }\n  }\n  \n  // If there's only one player left, they're the winner\n  if (players.size === 1) {\n    return Array.from(players)[0];\n  }\n  \n  // Game still ongoing\n  return null;\n};\n\n// Get the background color for the current turn\nexport const getTurnBackgroundColor = (currentPlayer: PLAYER): string => {\n  return currentPlayer === PLAYER.RED \n    ? \"rgb(255, 230, 230)\" // Light red\n    : \"rgb(230, 242, 255)\"; // Light blue\n};\n\n// Get text color based on background for better contrast\nexport const getTextColor = (bgColor: string): string => {\n  // Simple check - if background is dark, use white text, otherwise black\n  const isLight = bgColor.includes(\"255\") || bgColor.includes(\"230\");\n  return isLight ? \"#000000\" : \"#ffffff\";\n};\n","size_bytes":3242},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1376},"client/src/lib/useAITurn.tsx":{"content":"import { useEffect } from 'react';\nimport { PLAYER } from './constants';\nimport { useChainReaction } from './stores/useChainReaction';\nimport { PlayerSettingsManager, PLAYER_CONTROL } from '../components/Menu/MainMenu';\nimport { getAIMove, AI_STRATEGY } from './aiPlayer';\n\n/**\n * A React hook to process AI turns\n */\nexport const useAITurn = () => {\n  const { \n    currentPlayer, \n    gameOver,\n    grid,\n    isBaseMode,\n    hqs,\n    powerUps,\n    placeDot,\n    animating\n  } = useChainReaction();\n\n  useEffect(() => {\n    // Skip if game is over or animations are in progress\n    if (gameOver || animating) {\n      return;\n    }\n\n    // Check if current player is AI-controlled\n    const isCurrentPlayerAI = PlayerSettingsManager.isAIPlayer(currentPlayer);\n    \n    if (isCurrentPlayerAI) {\n      console.log(`AI Turn for ${currentPlayer} player`);\n      \n      // Add a small delay to make the AI move feel more natural\n      const timeoutId = setTimeout(() => {\n        // Get the AI's strategy (default to hard for aggressive play)\n        const strategy = PlayerSettingsManager.getAIStrategy(currentPlayer);\n        const aiMove = getAIMove(grid, currentPlayer, isBaseMode, hqs, strategy, powerUps);\n        \n        if (aiMove) {\n          console.log(`AI ${currentPlayer} (${strategy}) placed dot at (${aiMove.row}, ${aiMove.col}) with score ${aiMove.score.toFixed(1)}`);\n          placeDot(aiMove.row, aiMove.col);\n        } else {\n          console.warn(`AI ${currentPlayer} couldn't find a valid move`);\n        }\n      }, 750); // Delay AI moves by 750ms\n      \n      return () => clearTimeout(timeoutId);\n    }\n  }, [currentPlayer, gameOver, grid, isBaseMode, hqs, powerUps, placeDot, animating]);\n};","size_bytes":1713},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nconst getLocalStorage = (key: string): any =>\n  JSON.parse(window.localStorage.getItem(key) || \"null\");\nconst setLocalStorage = (key: string, value: any): void =>\n  window.localStorage.setItem(key, JSON.stringify(value));\n\nexport { getLocalStorage, setLocalStorage };\n","size_bytes":438},"client/src/pages/BaseReactionMode.tsx":{"content":"import React, { useEffect, useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport GameBoard from \"../components/Game/GameBoard\";\nimport GameControls from \"../components/Game/GameControls\";\nimport GameOverOverlay from \"../components/Game/GameOverOverlay\";\nimport { useChainReaction } from \"../lib/stores/useChainReaction\";\nimport { PLAYER_BG_COLORS } from \"../lib/constants\";\nimport { useAITurn } from \"../lib/useAITurn\";\nimport { resetAIPersonalities } from \"../lib/aiPlayer\";\nimport { PlayerSettingsManager } from \"../components/Menu/MainMenu\";\n\nconst BaseReactionMode: React.FC = () => {\n  const navigate = useNavigate();\n  const [isAnimating, setIsAnimating] = useState(false);\n  \n  // Initialize AI for automatic turns\n  useAITurn();\n  \n  const {\n    grid,\n    rows,\n    cols,\n    currentPlayer,\n    gameOver,\n    winner,\n    history,\n    hqs,\n    powerUps,\n    placeDot,\n    undo,\n    restart,\n    isValidMove,\n    initBaseMode\n  } = useChainReaction();\n  \n  // Initialize base mode on component mount\n  useEffect(() => {\n    resetAIPersonalities(); // Reset AI personalities for each new game\n    initBaseMode();\n    \n    // Set up keyboard shortcut for restarting with R\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"r\" || e.key === \"R\") {\n        resetAIPersonalities(); // Reset AI personalities on restart\n        restart();\n      }\n    };\n    \n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [initBaseMode, restart]);\n  \n  // Handle cell click\n  const handleCellClick = (row: number, col: number) => {\n    // Check if current player is AI-controlled\n    const isCurrentPlayerAI = PlayerSettingsManager.isAIPlayer(currentPlayer);\n    \n    // Check if it's an HQ cell\n    const isHQCell = hqs.some(hq => hq.row === row && hq.col === col);\n    \n    // Get heart selection mode from store\n    const { heartSelectionMode } = useChainReaction.getState();\n    \n    // Only allow clicks if:\n    // 1. Game is not over\n    // 2. Current player is NOT AI-controlled (prevent human playing during AI turn)\n    // 3. Either:\n    //    a. It's a valid move AND not an HQ cell (normal gameplay)\n    //    b. We're in heart selection mode (allow HQ clicks for heart targeting)\n    if (!gameOver && !isCurrentPlayerAI && \n        ((isValidMove(row, col) && !isHQCell) || heartSelectionMode)) {\n      placeDot(row, col);\n      \n      // Add fallback timeout to ensure animation state resets\n      // Using a shorter timeout for better responsiveness\n      setTimeout(() => {\n        // Always reset animation state\n        console.log(\"Animation timeout in BaseReactionMode - forcing reset\");\n        setIsAnimating(false);\n      }, 200); // Very short timeout for better responsiveness\n    }\n  };\n\n  return (\n    <div \n      className=\"min-h-screen flex flex-col items-center p-2 md:p-4 transition-colors duration-500\"\n      style={{ backgroundColor: PLAYER_BG_COLORS[currentPlayer] }}\n    >\n      <h1 className=\"text-3xl font-bold mb-6 text-white pt-4\" style={{ fontFamily: 'Menlo, monospace' }}>Base Reaction</h1>\n      \n      <GameControls\n        currentPlayer={currentPlayer}\n        onUndo={undo}\n        onRestart={restart}\n        canUndo={history.length > 0}\n        isBaseMode={true}\n      />\n      \n      <GameBoard\n        grid={grid}\n        rows={rows}\n        cols={cols}\n        currentPlayer={currentPlayer}\n        onCellClick={handleCellClick}\n        isValidMove={isValidMove}\n        powerUps={powerUps}\n        hqs={hqs}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n      />\n      \n      {/* Power-up explainer removed and moved to Tutorial */}\n      \n      {gameOver && winner && (\n        <GameOverOverlay\n          winner={winner}\n          onRestart={restart}\n          onBackToMenu={() => navigate(\"/\")}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default BaseReactionMode;\n","size_bytes":3976},"client/src/pages/ClassicMode.tsx":{"content":"import React, { useEffect, useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport GameBoard from \"../components/Game/GameBoard\";\nimport GameControls from \"../components/Game/GameControls\";\nimport GameOverOverlay from \"../components/Game/GameOverOverlay\";\nimport { useChainReaction } from \"../lib/stores/useChainReaction\";\nimport { PLAYER_BG_COLORS } from \"../lib/constants\";\nimport { useAITurn } from \"../lib/useAITurn\";\nimport { resetAIPersonalities } from \"../lib/aiPlayer\";\nimport { PlayerSettingsManager } from \"../components/Menu/MainMenu\";\n\nconst ClassicMode: React.FC = () => {\n  const navigate = useNavigate();\n  const [isAnimating, setIsAnimating] = useState(false);\n  \n  // Initialize AI for automatic turns\n  useAITurn();\n  \n  const {\n    grid,\n    rows,\n    cols,\n    currentPlayer,\n    gameOver,\n    winner,\n    history,\n    placeDot,\n    undo,\n    restart,\n    isValidMove,\n    initClassicMode\n  } = useChainReaction();\n  \n  // Initialize classic mode on component mount\n  useEffect(() => {\n    resetAIPersonalities(); // Reset AI personalities for each new game\n    initClassicMode();\n    \n    // Set up keyboard shortcut for restarting with R\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"r\" || e.key === \"R\") {\n        resetAIPersonalities(); // Reset AI personalities on restart\n        restart();\n      }\n    };\n    \n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [initClassicMode, restart]);\n  \n  // Handle cell click\n  const handleCellClick = (row: number, col: number) => {\n    // Check if current player is AI-controlled\n    const isCurrentPlayerAI = PlayerSettingsManager.isAIPlayer(currentPlayer);\n    \n    // Only allow clicks if:\n    // 1. Game is not over\n    // 2. It's a valid move\n    // 3. Current player is NOT AI-controlled (prevent human playing during AI turn)\n    if (!gameOver && isValidMove(row, col) && !isCurrentPlayerAI) {\n      placeDot(row, col);\n      \n      // Add fallback timeout to ensure animation state resets\n      // Using a shorter timeout for better responsiveness\n      setTimeout(() => {\n        // Always reset animation state\n        console.log(\"Animation timeout in ClassicMode - forcing reset\");\n        setIsAnimating(false);\n      }, 200); // Very short timeout for better responsiveness\n    }\n  };\n\n  return (\n    <div \n      className=\"min-h-screen flex flex-col items-center p-2 md:p-4 transition-colors duration-500\"\n      style={{ backgroundColor: PLAYER_BG_COLORS[currentPlayer] }}\n    >\n      <h1 className=\"text-3xl font-bold mb-6 text-white pt-4\" style={{ fontFamily: 'Menlo, monospace' }}>Chain Reaction</h1>\n      \n      <GameControls\n        currentPlayer={currentPlayer}\n        onUndo={undo}\n        onRestart={restart}\n        canUndo={history.length > 0}\n        isBaseMode={false}\n      />\n      \n      <GameBoard\n        grid={grid}\n        rows={rows}\n        cols={cols}\n        currentPlayer={currentPlayer}\n        onCellClick={handleCellClick}\n        isValidMove={isValidMove}\n        isAnimating={isAnimating}\n        setIsAnimating={setIsAnimating}\n      />\n      \n      {gameOver && winner && (\n        <GameOverOverlay\n          winner={winner}\n          onRestart={restart}\n          onBackToMenu={() => navigate(\"/\")}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ClassicMode;\n","size_bytes":3429},"client/src/pages/Home.tsx":{"content":"import React from \"react\";\nimport MainMenu from \"../components/Menu/MainMenu\";\n\nconst Home: React.FC = () => {\n  return <MainMenu />;\n};\n\nexport default Home;\n","size_bytes":159},"client/src/pages/not-found.tsx":{"content":"import React from \"react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center\" style={{ background: \"rgba(0,0,0,0.8)\" }}>\n      <div className=\"w-full max-w-md mx-4 p-6 rounded-lg\" style={{ background: \"rgba(255,255,255,0.1)\", backdropFilter: \"blur(4px)\", border: \"1px solid rgba(255,255,255,0.3)\" }}>\n        <div className=\"flex mb-4 gap-2 items-center\">\n          <div className=\"h-8 w-8 flex items-center justify-center rounded-full bg-red-500 text-white font-bold\">!</div>\n          <h1 className=\"text-2xl font-bold text-white\">404 Page Not Found</h1>\n        </div>\n\n        <p className=\"mt-4 text-sm text-gray-200\">\n          Please return to the <a href=\"/\" className=\"text-blue-300 hover:text-blue-200\">main menu</a>.\n        </p>\n      </div>\n    </div>\n  );\n}\n","size_bytes":844},"client/src/components/Game/BoardCell.tsx":{"content":"import React, { useRef, useEffect, useState } from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { \n  CELL_SIZE, \n  DOT_SIZE, \n  PLAYER_COLORS, \n  ANIMATION_DURATION \n} from \"../../lib/constants\";\nimport { \n  getDotPositions, \n  calculateCriticalMass, \n  isAboutToExplode, \n  randomOffset \n} from \"../../lib/gameUtils\";\nimport type { GridCell, PowerUpType } from \"../../lib/stores/useChainReaction\";\n\ntype BoardCellProps = {\n  row: number;\n  col: number;\n  cell: GridCell;\n  totalRows: number;\n  totalCols: number;\n  onCellClick: (row: number, col: number) => void;\n  isValidMove: boolean;\n  powerUpType?: PowerUpType;\n  isHQ?: boolean;\n  hqHealth?: number;\n  maxHqHealth?: number; // Track max health to calculate damage spots\n  isHQDamaged?: boolean; // Track if this HQ cell was just damaged\n  isHQHealed?: boolean; // Track if this HQ cell was just healed\n  isHQDestroyed?: boolean; // Track if this HQ cell was just destroyed\n  heartSelectionMode?: boolean; // Track if we're in heart selection mode\n  pendingHeartPlayer?: string; // Track which player triggered the heart\n};\n\nconst BoardCell: React.FC<BoardCellProps> = ({\n  row,\n  col,\n  cell,\n  totalRows,\n  totalCols,\n  onCellClick,\n  isValidMove,\n  powerUpType,\n  isHQ,\n  hqHealth,\n  maxHqHealth = 5,\n  isHQDamaged,\n  isHQHealed,\n  isHQDestroyed,\n  heartSelectionMode = false,\n  pendingHeartPlayer\n}) => {\n  const criticalMass = calculateCriticalMass(row, col, totalRows, totalCols);\n  const aboutToExplode = isAboutToExplode(cell, row, col, totalRows, totalCols);\n  const cellRef = useRef<HTMLDivElement>(null);\n\n  // Check if this HQ is a valid heart target\n  const isHeartTarget = heartSelectionMode && isHQ && cell.player !== pendingHeartPlayer && cell.player !== null;\n  \n  // Debug logging for heart selection\n  if (heartSelectionMode) {\n    console.log(`Heart selection active - Cell (${row},${col}): isHQ=${isHQ}, cellPlayer=${cell.player}, pendingHeartPlayer=${pendingHeartPlayer}, isHeartTarget=${isHeartTarget}`);\n  }\n\n  // Get position of dots in the cell\n  const positions = getDotPositions(cell.atoms, CELL_SIZE, DOT_SIZE);\n  \n  // Create state to hold shaking positions\n  // Initialize with one offset per atom\n  const [shakeOffsets, setShakeOffsets] = useState(() => \n    Array.from({length: cell.atoms}, () => ({x: 0, y: 0}))\n  );\n  \n  // Update the animation effect when aboutToExplode changes or atoms change\n  useEffect(() => {\n    if (aboutToExplode && cell.atoms > 0) {\n      // Use proper shaking animation for cells about to explode\n      const interval = setInterval(() => {\n        // Use more noticeable shake offsets\n        setShakeOffsets(\n          Array.from({length: cell.atoms}, () => ({\n            x: randomOffset(7), // Increased shake intensity\n            y: randomOffset(7)\n          }))\n        );\n      }, 50); // Faster interval for more visible shaking\n      \n      return () => clearInterval(interval);\n    } else {\n      // Reset offsets when not about to explode\n      setShakeOffsets(Array.from({length: cell.atoms}, () => ({x: 0, y: 0})));\n    }\n  }, [aboutToExplode, cell.atoms]);\n\n  return (\n    <div className=\"relative\" style={{ width: CELL_SIZE, height: CELL_SIZE }}>\n\n  \n      {/* Main cell content */}\n      <div\n        ref={cellRef}\n        className=\"relative\"\n        style={{\n          width: CELL_SIZE,\n          height: CELL_SIZE,\n          cursor: (isValidMove || isHeartTarget) ? \"pointer\" : \"not-allowed\",\n          backgroundColor: isHQ \n            ? `${PLAYER_COLORS[cell.player!]}66` // 40% opacity of player color for HQ\n            : \"rgba(255, 255, 255, 0.1)\", // Slightly visible white background\n          border: \"none\", // Remove border for completely flat look\n          margin: \"1px\",\n          transition: \"all 0.3s ease\", // Match the background transition speed\n          zIndex: 2\n        }}\n        onClick={() => {\n          console.log(`ðŸŽ¯ BoardCell.onClick: (${row},${col}) - isValidMove=${isValidMove}, isHeartTarget=${isHeartTarget}, heartSelectionMode=${heartSelectionMode}`);\n          if (isValidMove || isHeartTarget) {\n            console.log(`ðŸŽ¯ BoardCell: Calling onCellClick for (${row},${col})`);\n            onCellClick(row, col);\n          } else {\n            console.log(`ðŸŽ¯ BoardCell: Click blocked for (${row},${col}) - not valid move or heart target`);\n          }\n        }}\n      >\n        {/* Power-up icon if present - completely flat with same transition speed and strong green glow */}\n        {powerUpType && cell.atoms === 0 && (\n          <div className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ \n            transition: \"all 0.3s ease\", // Match the background transition speed\n            overflow: \"visible\", // Allow glow to extend beyond boundaries\n            zIndex: 10 // Ensure glow appears on top\n          }}\n        >\n          {powerUpType === 'diamond' && (\n            <div style={{\n              filter: \"drop-shadow(0 0 12px rgb(0, 255, 0)) drop-shadow(0 0 20px rgba(0, 255, 0, 0.5))\", // Strong green glow without container clipping\n              transition: \"all 0.3s ease\"\n            }}>\n              <svg \n                width=\"26\" \n                height=\"26\" \n                viewBox=\"0 0 24 24\" \n                fill=\"rgb(50, 200, 50)\" \n                stroke=\"rgb(0, 200, 0)\" \n                strokeWidth=\"1\"\n                style={{ \n                  transition: \"all 0.3s ease\" // Match the background transition speed\n                }}\n              >\n                <path d=\"M12 2L2 12L12 22L22 12L12 2Z\" />\n              </svg>\n            </div>\n          )}\n          {powerUpType === 'heart' && (\n            <div style={{\n              filter: \"drop-shadow(0 0 12px rgb(0, 255, 0)) drop-shadow(0 0 20px rgba(0, 255, 0, 0.5))\", // Strong green glow without container clipping\n              transition: \"all 0.3s ease\"\n            }}>\n              <svg \n                width=\"26\" \n                height=\"26\" \n                viewBox=\"0 0 24 24\" \n                fill=\"rgb(50, 200, 50)\" \n                stroke=\"rgb(0, 200, 0)\" \n                strokeWidth=\"1\"\n                style={{ \n                  transition: \"all 0.3s ease\" // Match the background transition speed\n                }}\n              >\n                <path d=\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\" />\n              </svg>\n            </div>\n          )}\n          </div>\n        )}\n\n      {/* HQ base circle - only show if health > 0 */}\n      {isHQ && hqHealth !== undefined && hqHealth > 0 && (\n        <div className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ \n            padding: '2px'\n          }}\n        >\n          <motion.div \n            className=\"rounded-full flex items-center justify-center\"\n            initial={{ scale: 1.3 }}\n            animate={(isHQDamaged || isHQHealed) ? {\n              scale: [1.3, 1.5, 1.3]\n            } : {\n              scale: 1.3\n            }}\n            transition={{ \n              duration: 0.5,\n              ease: \"easeInOut\"\n            }}\n            style={{\n              width: '80%', \n              height: '80%',\n              backgroundColor: PLAYER_COLORS[cell.player!],\n              zIndex: 25\n            }}\n          >\n          </motion.div>\n          \n          <AnimatePresence>\n            {isHQDamaged &&(\n              <>\n                {/* Electrical damage effect - black flash with cyan glow */}\n                <motion.div\n                  className=\"absolute inset-0 rounded-full\"\n                  initial={{ scale: 1, opacity: 0 }}\n                  animate={{ \n                    scale: [1.7, 1.1, 1], \n                    opacity: [0, 1, 0],\n                    backgroundColor: ['rgba(0, 0, 0, 0)', 'rgba(0, 0, 0, 0.9)', 'rgba(0, 0, 0, 0)']\n                  }}\n                  exit={{ opacity: 1 }}\n                  transition={{ duration: 0.3, times: [0, 0.5, 1] }}\n                  style={{\n                    boxShadow: '0 0 20px cyan, 0 0 40px cyan, 0 0 60px rgba(0, 255, 255, 0.5)',\n                    border: '2px solid cyan'\n                  }}\n                />\n                \n                {/* 100 gray particles exploding in all directions from whole circle */}\n                {Array.from({ length: 100 }).map((_, i) => {\n                  const angle = (i * 360) / 100 + Math.random() * 5; // Even distribution with slight randomness\n                  const distance = 50 + Math.random() * 110; // Much farther spread\n                  const size = 2 + Math.random() * 6;\n                  const grayShade = 100 + Math.random() * 100; // Different shades of gray\n                  \n                  // Start from edge of circle, not center\n                  const startRadius = 30; // Start from edge of HQ base\n                  const startX = Math.cos(angle * Math.PI / 180) * startRadius;\n                  const startY = Math.sin(angle * Math.PI / 180) * startRadius;\n                  \n                  // Final position\n                  const endX = Math.cos(angle * Math.PI / 180) * distance;\n                  const endY = Math.sin(angle * Math.PI / 180) * distance;\n                  \n                  return (\n                    <motion.div\n                      key={`damage-particle-${i}`}\n                      className=\"absolute rounded-full\"\n                      initial={{ \n                        scale: 1, \n                        opacity: 1,\n                        x: startX, // Start from edge of circle\n                        y: startY\n                      }}\n                      animate={{ \n                        scale: [1, 0.8, 0.6, 0],\n                        opacity: [1, 0.8, 0.4, 0],\n                        x: endX,\n                        y: endY\n                      }}\n                      exit={{ opacity: 1 }}\n                      transition={{ \n                        duration: 1.5,\n                        delay: 0, // All particles start at once\n                        ease: [0.15, 0.46, 0.45, 0.94] // Custom bezier for sin-like deceleration\n                      }}\n                      style={{\n                        width: size,\n                        height: size,\n                        backgroundColor: `rgb(${grayShade}, ${grayShade}, ${grayShade})`,\n                        left: '50%',\n                        top: '50%'\n                      }}\n                    />\n                  );\n                })}\n              </>\n            )}\n          </AnimatePresence>\n          \n          <AnimatePresence>\n            {isHQHealed && (\n              <>\n                {/* Only keep the healing ring effect */}\n                <motion.div\n                  className=\"absolute inset-0 rounded-full\"\n                  initial={{ scale: 0.8, opacity: 0.8 }}\n                  animate={{ scale: 1.8, opacity: 0 }}\n                  exit={{ opacity: 0 }}\n                  transition={{ duration: 0.7 }}\n                  style={{\n                    backgroundColor: 'transparent',\n                    border: `3px solid rgba(100, 255, 100, 0.8)`,\n                    boxShadow: 'none' // No shadow for flat design\n                  }}\n                />\n              </>\n            )}\n          </AnimatePresence>\n          \n          <AnimatePresence>\n            {isHQDestroyed &&(\n          <>\n            {/* Electrical damage effect - black flash with cyan glow */}\n            <motion.div\n              className=\"absolute inset-0 rounded-full\"\n              initial={{ scale: 1, opacity: 0 }}\n              animate={{ \n                scale: [1.7, 1.1, 1], \n                opacity: [0, 1, 0],\n                backgroundColor: ['rgba(0, 0, 0, 0)', 'rgba(0, 0, 0, 0.9)', 'rgba(0, 0, 0, 0)']\n              }}\n              exit={{ opacity: 1 }}\n              transition={{ duration: 0.3, times: [0, 0.5, 1] }}\n              style={{\n                boxShadow: '0 0 20px cyan, 0 0 40px cyan, 0 0 60px rgba(0, 255, 255, 0.5)',\n                border: '2px solid cyan'\n              }}\n            />\n\n            {/* 100 gray particles exploding in all directions from whole circle */}\n            {Array.from({ length: 200 }).map((_, i) => {\n              const angle = (i * 360) / 100 + Math.random() * 5; // Even distribution with slight randomness\n              const distance = 50 + Math.random() * 210; // Much farther spread\n              const size = 2 + Math.random() * 7;\n              const grayShade = 100 + Math.random() * 100; // Different shades of gray\n\n              // Start from edge of circle, not center\n              const startRadius = 30; // Start from edge of HQ base\n              const startX = Math.cos(angle * Math.PI / 180) * startRadius;\n              const startY = Math.sin(angle * Math.PI / 180) * startRadius;\n\n              // Final position\n              const endX = Math.cos(angle * Math.PI / 180) * distance;\n              const endY = Math.sin(angle * Math.PI / 180) * distance;\n\n              return (\n                <motion.div\n                  key={`damage-particle-${i}`}\n                  className=\"absolute rounded-full\"\n                  initial={{ \n                    scale: 1, \n                    opacity: 1,\n                    x: startX, // Start from edge of circle\n                    y: startY\n                  }}\n                  animate={{ \n                    scale: [1, 0.8, 0.6, 0],\n                    opacity: [1, 0.8, 0.4, 0],\n                    x: endX,\n                    y: endY\n                  }}\n                  exit={{ opacity: 1 }}\n                  transition={{ \n                    duration: 1.5,\n                    delay: 0, // All particles start at once\n                    ease: [0.15, 0.46, 0.45, 0.94] // Custom bezier for sin-like deceleration\n                  }}\n                  style={{\n                    width: size,\n                    height: size,\n                    backgroundColor: `rgb(${grayShade}, ${grayShade}, ${grayShade})`,\n                    left: '50%',\n                    top: '50%'\n                  }}\n                />\n              );\n            })}\n          </>\n          )}\n          </AnimatePresence>\n        </div>\n      )}\n\n      {/* Render atoms (except on HQ cells in base mode) */}\n      <AnimatePresence>\n        {cell.atoms > 0 && cell.player && !isHQ && (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            {positions.map((pos, index) => (\n              <motion.div\n                key={`${row}-${col}-${index}`}\n                initial={{ \n                  scale: 0,\n                  x: 0, // Start from center for smoother animation\n                  y: 0\n                }}\n                animate={{ \n                  scale: 1,\n                  x: aboutToExplode ? pos.x + shakeOffsets[index]?.x || 0 : pos.x,\n                  y: aboutToExplode ? pos.y + shakeOffsets[index]?.y || 0 : pos.y\n                }}\n                exit={{ \n                  scale: [1, 0.8, 0],\n                  x: [pos.x, pos.x * 1.5], // Move slightly outward when disappearing\n                  y: [pos.y, pos.y * 1.5]\n                }}\n                transition={{ \n                  duration: ANIMATION_DURATION / 1000,\n                  type: aboutToExplode ? \"tween\" : \"spring\",\n                  stiffness: 300,\n                  damping: 20,\n                  repeat: 0\n                }}\n                className=\"absolute rounded-full\"\n                style={{\n                  width: DOT_SIZE,\n                  height: DOT_SIZE,\n                  backgroundColor: PLAYER_COLORS[cell.player!],\n                  boxShadow: aboutToExplode \n                    ? `0 0 8px ${PLAYER_COLORS[cell.player!]}` // Strong glow effect when near critical\n                    : `0 0 2px ${PLAYER_COLORS[cell.player!]}`, // Very slight glow at all times\n                  transform: `scale(${(cell.atoms / criticalMass) * 0.7 + 0.3})` // Shrink based on critical mass ratio (min 0.3, max 1.0)\n                }}\n              />\n            ))}\n          </div>\n        )}\n      </AnimatePresence>\n      \n      {/* Health number*/}\n      {isHQ && hqHealth !== undefined && (\n        <div \n          className=\"absolute inset-0 flex items-center justify-center pointer-events-none text-white font-bold text-2xl\"\n          style={{\n      \n            zIndex: 30\n          }}\n        >\n          {hqHealth}\n        </div>\n      )}\n\n      {/* HQ Glow effect - 4 layers for strong glow */}\n        {isHQ && hqHealth !== undefined && (\n          <div\n            className=\"absolute inset-1 rounded-full pointer-events-none\"\n            style={{\n              zIndex: 35,\n              boxShadow: `\n                0 0 ${hqHealth * 8}px ${PLAYER_COLORS[cell.player!]},\n                0 0 ${hqHealth * 8}px ${PLAYER_COLORS[cell.player!]},\n                0 0 ${hqHealth * 16}px ${PLAYER_COLORS[cell.player!]},\n                0 0 ${hqHealth * 32}px ${PLAYER_COLORS[cell.player!]}\n              `\n            }}\n          />\n        )}\n\n      {/* Heart selection mode - cyan diagonal lines for enemy HQ targets */}\n      {isHeartTarget && (\n        <div className=\"absolute inset-0 pointer-events-none\" style={{ zIndex: 40 }}>\n          {/* Diagonal lines overlay - only lines, no circle */}\n          <div\n            className=\"absolute inset-0 rounded-full\"\n            style={{\n              background: `repeating-linear-gradient(\n                45deg,\n                rgba(0, 255, 255, 0.6) 0px,\n                rgba(0, 255, 255, 0.6) 2px,\n                transparent 2px,\n                transparent 6px\n              )`\n            }}\n          />\n        </div>\n      )}\n      \n      </div>\n    </div>\n  );\n};\n\nexport default BoardCell;","size_bytes":17873},"client/src/components/Game/GameBoard.tsx":{"content":"import React, { useState, useEffect } from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport BoardCell from \"./BoardCell\";\nimport { CELL_SIZE, PLAYER } from \"../../lib/constants\";\nimport type { GridCell, PowerUpCell, HQCell } from \"../../lib/stores/useChainReaction\";\nimport { useAudio } from \"../../lib/stores/useAudio\";\nimport { useChainReaction } from \"../../lib/stores/useChainReaction\";\n\ninterface GameBoardProps {\n  grid: GridCell[][];\n  rows: number;\n  cols: number;\n  currentPlayer: PLAYER;\n  onCellClick: (row: number, col: number) => void;\n  isValidMove: (row: number, col: number) => boolean;\n  powerUps?: PowerUpCell[];\n  hqs?: HQCell[];\n  isAnimating: boolean;\n  setIsAnimating: (animating: boolean) => void;\n}\n\nconst GameBoard: React.FC<GameBoardProps> = ({\n  grid,\n  rows,\n  cols,\n  currentPlayer,\n  onCellClick,\n  isValidMove,\n  powerUps = [],\n  hqs = [],\n  isAnimating,\n  setIsAnimating\n}) => {\n  const [lastClickedCell, setLastClickedCell] = useState<{row: number, col: number} | null>(null);\n  const [gameStarted, setGameStarted] = useState(false);\n  const [scale, setScale] = useState(1);\n  const { playHit } = useAudio();\n  const { lastHQDamaged, heartSelectionMode, pendingHeartPlayer } = useChainReaction();\n  \n  // Trigger entrance animation immediately when the component mounts\n  useEffect(() => {\n    // Start animation immediately\n    setGameStarted(true);\n  }, []);\n\n  // Calculate responsive scale based on viewport\n  useEffect(() => {\n    const calculateScale = () => {\n      const boardWidth = cols * CELL_SIZE + cols * 2 + 24;\n      const boardHeight = rows * CELL_SIZE + rows * 2 + 24;\n      \n      const availableWidth = window.innerWidth - 32; // Account for padding\n      const availableHeight = window.innerHeight - 200; // Account for UI elements\n      \n      const scaleX = availableWidth / boardWidth;\n      const scaleY = availableHeight / boardHeight;\n      \n      // Use the smaller scale to ensure the board fits, but cap at 1 to avoid upscaling\n      const newScale = Math.min(scaleX, scaleY, 1);\n      setScale(newScale);\n    };\n\n    calculateScale();\n    window.addEventListener('resize', calculateScale);\n    return () => window.removeEventListener('resize', calculateScale);\n  }, [rows, cols]);\n  \n  // Handle cell click with animation tracking\n  const handleCellClick = (row: number, col: number) => {\n    // Play sound effect\n    playHit();\n    \n    // Track this cell as last clicked\n    setLastClickedCell({row, col});\n    \n    // Start animation and then process the move\n    setIsAnimating(true);\n    console.log(`ðŸŽ¯ GameBoard.handleCellClick: (${row},${col}) - heartSelectionMode=${heartSelectionMode}, pendingHeartPlayer=${pendingHeartPlayer}`);\n    \n    // Process the move immediately but keep animation state\n    onCellClick(row, col);\n    \n    // Set a fallback timer to reset animation state in case the chain reaction logic doesn't do it\n    // This timer is shorter for cells that don't trigger a chain reaction\n    setTimeout(() => {\n      // Always reset animation flag after a short delay\n      console.log(\"Animation timeout reached - resetting animation state\");\n      setIsAnimating(false);\n    }, 200); // Even shorter timeout for better responsiveness\n  };\n  \n  // Get the power-up type for a specific cell\n  const getPowerUpType = (row: number, col: number) => {\n    const powerUp = powerUps.find(p => p.row === row && p.col === col);\n    return powerUp?.type || null;\n  };\n  \n  // Check if a cell is an HQ\n  const getHQInfo = (row: number, col: number) => {\n    const hq = hqs.find(h => h.row === row && h.col === col);\n    return hq ? { isHQ: true, health: hq.health } : { isHQ: false };\n  };\n  \n  // Define the entrance animation\n  const boardContainerVariants = {\n    hidden: { \n      scale: 0.8, \n      opacity: 1,\n      rotate: -45,\n      transformOrigin: \"center center\"\n    },\n    visible: { \n      scale: 1, \n      opacity: 1,\n      rotate: 0,\n      transition: {\n        type: \"spring\",\n        stiffness: 200,\n        damping: 20,\n        duration: 0.5,\n        delay: 0\n      }\n    }\n  };\n\n  return (\n    <div className=\"flex items-center justify-center\">\n      <motion.div \n        className=\"relative\"\n        initial=\"hidden\"\n        animate={gameStarted ? \"visible\" : \"hidden\"}\n        variants={boardContainerVariants}\n        style={{ \n          width: cols * CELL_SIZE + cols * 2 + 24,\n          height: rows * CELL_SIZE + rows * 2 + 24,\n          background: \"rgba(255, 255, 255, 0.05)\",\n          border: \"none\",\n          boxShadow: \"0 0 40px rgba(255, 255, 255, 0.3)\",\n          transformOrigin: 'center',\n          transform: `scale(${scale})`,\n          padding: '12px',\n          borderRadius: '16px'\n        }}\n      >\n\n        \n      {grid.map((rowCells, rowIndex) => (\n        <div key={`row-${rowIndex}`} className=\"flex gap-[2px]\" style={{ zIndex: 10, position: 'relative', marginBottom: rowIndex < rows - 1 ? '2px' : '0' }}>\n          {rowCells.map((cell, colIndex) => {\n            const powerUpType = getPowerUpType(rowIndex, colIndex);\n            const { isHQ, health } = getHQInfo(rowIndex, colIndex);\n            const isHighlighted = lastClickedCell?.row === rowIndex && lastClickedCell?.col === colIndex;\n            \n            // Check if this is an HQ that was just damaged or healed\n            // Add key based on current timestamp to force re-render and animation\n            const isHQEffected = isHQ && lastHQDamaged !== undefined && \n                               lastHQDamaged.row === rowIndex && \n                               lastHQDamaged.col === colIndex;\n            // Get the effect type if any\n            const hqEffectType = isHQEffected ? lastHQDamaged?.type : undefined;\n            \n            return (\n              <motion.div\n                // Add lastHQDamaged timestamp to key to force re-render when damage occurs\n                key={`cell-${rowIndex}-${colIndex}${isHQEffected ? `-${lastHQDamaged?.timestamp}` : ''}`}\n                whileHover={{ scale: isValidMove(rowIndex, colIndex) ? 1.05 : 1 }}\n                animate={{ \n                  scale: isHighlighted ? [1, 1.1, 1] : 1,\n                  transition: { duration: 0.3 }\n                }}\n              >\n                <BoardCell\n                  key={isHQ ? `hq-${health}-${isHQEffected ? lastHQDamaged?.timestamp : Date.now()}` : undefined}\n                  row={rowIndex}\n                  col={colIndex}\n                  cell={cell}\n                  totalRows={rows}\n                  totalCols={cols}\n                  onCellClick={handleCellClick}\n                  isValidMove={isValidMove(rowIndex, colIndex)}\n                  powerUpType={powerUpType}\n                  isHQ={isHQ}\n                  hqHealth={health}\n                  maxHqHealth={5}\n                  isHQDamaged={isHQEffected && hqEffectType === 'damage'}\n                  isHQHealed={isHQEffected && hqEffectType === 'heal'}\n                  isHQDestroyed={isHQEffected && hqEffectType === 'destroyed'}\n                  heartSelectionMode={heartSelectionMode}\n                  pendingHeartPlayer={pendingHeartPlayer || undefined}\n                />\n              </motion.div>\n            );\n          })}\n        </div>\n      ))}\n      </motion.div>\n    </div>\n  );\n};\n\nexport default GameBoard;\n","size_bytes":7328},"client/src/components/Game/GameControls.tsx":{"content":"import React, { useEffect } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { PLAYER, PLAYER_COLORS, PLAYER_BG_COLORS } from \"../../lib/constants\";\nimport { PlayerSettingsManager, PLAYER_CONTROL } from \"../Menu/MainMenu\";\n\ninterface GameControlsProps {\n  currentPlayer: PLAYER;\n  onUndo: () => void;\n  onRestart: () => void;\n  canUndo: boolean;\n  isBaseMode: boolean;\n}\n\nconst GameControls: React.FC<GameControlsProps> = ({\n  currentPlayer,\n  onUndo,\n  onRestart,\n  canUndo,\n  isBaseMode\n}) => {\n  const navigate = useNavigate();\n\n  // Set up keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // R key restarts the game\n      if (e.key === \"r\" || e.key === \"R\") {\n        onRestart();\n      }\n\n      // Z key (with Ctrl/Cmd) for undo\n      if ((e.ctrlKey || e.metaKey) && (e.key === \"z\" || e.key === \"Z\") && canUndo) {\n        onUndo();\n      }\n\n      // Escape key to go back to menu\n      if (e.key === \"Escape\") {\n        navigate(\"/\");\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [canUndo, onRestart, onUndo, navigate]);\n\n  return (\n    <div \n      className=\"flex flex-col items-center justify-center w-full max-w-3xl p-4 mb-6\"\n      style={{ \n        backgroundColor: 'transparent',\n        transition: \"background-color 0.5s ease\"\n      }}\n    >\n      <div className=\"flex items-center space-x-10\">\n        <button\n          onClick={onUndo}\n          disabled={!canUndo}\n          className={`px-6 py-3 rounded-xl text-white text-base font-medium transition-all duration-500 ${\n            canUndo \n              ? \"hover:opacity-80\" \n              : \"opacity-50 cursor-not-allowed\"\n          }`}\n          style={{ \n            fontFamily: 'Menlo, monospace',\n            backgroundColor: 'rgb(20, 20, 20)', // Really dark gray with no transparency\n            border: 'none',\n            transition: \"opacity 0.3s ease\" // Simplified transition\n          }}\n        >\n          Undo\n        </button>\n\n        <button\n          onClick={onRestart}\n          className=\"px-6 py-3 rounded-xl text-white text-base font-medium hover:opacity-80 transition-all duration-500\"\n          style={{ \n            fontFamily: 'Menlo, monospace',\n            backgroundColor: 'rgb(20, 20, 20)', // Really dark gray with no transparency\n            border: 'none',\n            transition: \"opacity 0.3s ease\" // Simplified transition\n          }}\n        >\n          Restart\n        </button>\n\n        <button\n          onClick={() => navigate(\"/\")}\n          className=\"px-6 py-3 rounded-xl text-white text-base font-medium hover:opacity-80 transition-all duration-500\"\n          style={{ \n            fontFamily: 'Menlo, monospace',\n            backgroundColor: 'rgb(20, 20, 20)', // Really dark gray with no transparency\n            border: 'none',\n            transition: \"opacity 0.3s ease\" // Simplified transition\n          }}\n        >\n          Menu\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default GameControls;","size_bytes":3117},"client/src/components/Game/GameOverOverlay.tsx":{"content":"import React from \"react\";\nimport { motion } from \"framer-motion\";\nimport { PLAYER, PLAYER_COLORS } from \"../../lib/constants\";\n\ninterface GameOverOverlayProps {\n  winner: PLAYER | null;\n  onRestart: () => void;\n  onBackToMenu: () => void;\n}\n\nconst GameOverOverlay: React.FC<GameOverOverlayProps> = ({\n  winner,\n  onRestart,\n  onBackToMenu\n}) => {\n  \n  if (!winner) return null;\n  \n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"fixed inset-0 flex items-center justify-center bg-black bg-opacity-70 z-50\"\n    >\n      <motion.div\n        initial={{ scale: 0.8, opacity: 0 }}\n        animate={{ scale: 1, opacity: 1 }}\n        transition={{ type: \"spring\", damping: 15 }}\n        className=\"bg-black text-white rounded-lg p-8 max-w-md w-full mx-4\"\n        style={{ transition: \"all 0.3s ease\" }}\n      >\n        <h2 className=\"text-3xl font-bold text-center mb-6\" style={{ fontFamily: 'Menlo, monospace' }}>Game Over!</h2>\n        \n        <div className=\"flex items-center justify-center mb-8\">\n          <div \n            className=\"w-12 h-12 rounded-full mr-4\" \n            style={{ backgroundColor: PLAYER_COLORS[winner] }}\n          ></div>\n          <p className=\"text-2xl font-bold\" style={{ fontFamily: 'Menlo, monospace' }}>\n            {winner === PLAYER.RED ? \"Red\" : \n             winner === PLAYER.BLUE ? \"Blue\" : \n             winner === PLAYER.BLACK ? \"Black\" : \n             winner === PLAYER.VIOLET ? \"Yellow\" : \"Player\"} wins!\n          </p>\n        </div>\n        \n        <div className=\"flex flex-col space-y-4\">\n          <motion.button\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={onRestart}\n            className=\"py-3 px-6 bg-black hover:bg-gray-800 rounded-2xl text-white transition-all duration-300 border-2 border-white\"\n            style={{ \n              fontFamily: 'Menlo, monospace'\n            }}\n          >\n            Play Again\n          </motion.button>\n          \n          <motion.button\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={onBackToMenu}\n            className=\"py-3 px-6 bg-black hover:bg-gray-800 rounded-2xl text-white transition-all duration-300 border-2 border-white\"\n            style={{ \n              fontFamily: 'Menlo, monospace'\n            }}\n          >\n            Back to Menu\n          </motion.button>\n        </div>\n      </motion.div>\n    </motion.div>\n  );\n};\n\nexport default GameOverOverlay;\n","size_bytes":2531},"client/src/components/Menu/MainMenu.tsx":{"content":"import React, { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { motion } from \"framer-motion\";\nimport { PLAYER, PLAYER_COLORS } from \"../../lib/constants\";\nimport { AI_STRATEGY } from \"../../lib/aiPlayer\";\nimport TutorialScreen from \"./TutorialScreen\";\n\n// Enum to represent player control type\nexport enum PLAYER_CONTROL {\n  HUMAN = 'human',\n  AI = 'ai'\n}\n\n// Player settings interface with AI support\nexport type PlayerConfig = {\n  player: PLAYER;\n  control: PLAYER_CONTROL;\n  aiStrategy?: AI_STRATEGY;\n}\n\n// Create a store to save player selection\nexport type PlayerSelectionSettings = {\n  numberOfPlayers: 2 | 3 | 4;\n  players: PLAYER[];\n  playerConfigs: PlayerConfig[];\n};\n\n// Default player assignments by count\nexport const playerAssignments = {\n  2: [PLAYER.RED, PLAYER.BLUE],\n  3: [PLAYER.RED, PLAYER.BLUE, PLAYER.VIOLET],\n  4: [PLAYER.RED, PLAYER.BLUE, PLAYER.VIOLET, PLAYER.BLACK]\n};\n\n// Create default player configurations - all human players for multiplayer\nconst createDefaultPlayerConfigs = (players: PLAYER[]): PlayerConfig[] => {\n  return players.map(player => ({\n    player,\n    control: PLAYER_CONTROL.HUMAN, // Always human for all players in multiplayer\n    aiStrategy: undefined\n  }));\n};\n\n// Create a dedicated player settings module\nexport const PlayerSettingsManager = {\n  // Get current settings from localStorage\n  getSettings: (): PlayerSelectionSettings => {\n    const storedSettings = localStorage.getItem('playerSettings');\n    if (storedSettings) {\n      try {\n        const parsedSettings = JSON.parse(storedSettings);\n        \n        // Check if playerConfigs exists, if not add it\n        if (!parsedSettings.playerConfigs) {\n          parsedSettings.playerConfigs = createDefaultPlayerConfigs(parsedSettings.players);\n        }\n        \n        return parsedSettings;\n      } catch {\n        // If parsing fails, return default\n        const defaultPlayers = playerAssignments[2];\n        return { \n          numberOfPlayers: 2, \n          players: defaultPlayers,\n          playerConfigs: createDefaultPlayerConfigs(defaultPlayers)\n        };\n      }\n    }\n    \n    // Default settings\n    const defaultPlayers = playerAssignments[2];\n    return { \n      numberOfPlayers: 2, \n      players: defaultPlayers,\n      playerConfigs: createDefaultPlayerConfigs(defaultPlayers)\n    };\n  },\n  \n  // Save settings to localStorage\n  saveSettings: (settings: PlayerSelectionSettings): void => {\n    // Ensure playerConfigs exists\n    if (!settings.playerConfigs) {\n      settings.playerConfigs = createDefaultPlayerConfigs(settings.players);\n    }\n    \n    localStorage.setItem('playerSettings', JSON.stringify(settings));\n  },\n  \n  // Check if a player is AI-controlled\n  isAIPlayer: (player: PLAYER): boolean => {\n    const settings = PlayerSettingsManager.getSettings();\n    const playerConfig = settings.playerConfigs.find(config => config.player === player);\n    return playerConfig?.control === PLAYER_CONTROL.AI;\n  },\n  \n  // Get AI strategy for a player\n  getAIStrategy: (player: PLAYER): AI_STRATEGY => {\n    const settings = PlayerSettingsManager.getSettings();\n    const playerConfig = settings.playerConfigs.find(config => config.player === player);\n    return playerConfig?.aiStrategy || AI_STRATEGY.SMART;\n  },\n  \n  // Update a player's control type\n  setPlayerControl: (player: PLAYER, control: PLAYER_CONTROL, aiStrategy?: AI_STRATEGY): void => {\n    const settings = PlayerSettingsManager.getSettings();\n    \n    // Find and update the player config\n    const playerConfig = settings.playerConfigs.find(config => config.player === player);\n    if (playerConfig) {\n      playerConfig.control = control;\n      playerConfig.aiStrategy = control === PLAYER_CONTROL.AI ? \n        (aiStrategy || AI_STRATEGY.SMART) : undefined;\n    } else {\n      // If player config doesn't exist, create it\n      settings.playerConfigs.push({\n        player,\n        control,\n        aiStrategy: control === PLAYER_CONTROL.AI ? \n          (aiStrategy || AI_STRATEGY.SMART) : undefined\n      });\n    }\n    \n    // Save updated settings\n    PlayerSettingsManager.saveSettings(settings);\n  }\n};\n\n// Re-export methods to maintain backward compatibility\nexport const getPlayerSettings = (): PlayerSelectionSettings => {\n  return PlayerSettingsManager.getSettings();\n};\n\nexport const setPlayerSettings = (settings: PlayerSelectionSettings): void => {\n  PlayerSettingsManager.saveSettings(settings);\n};\n\nconst MainMenu: React.FC = () => {\n  const navigate = useNavigate();\n  \n  // Check for navigation state from tutorial\n  const location = window.location;\n  const navigationState = history.state?.usr;\n  \n  // Menu state\n  const [menuScreen, setMenuScreen] = useState<'main' | 'mode' | 'singleplayer' | 'multiplayer' | 'tutorial' | 'tutorial-content'>(() => {\n    if (navigationState?.openMultiplayer) {\n      return 'multiplayer';\n    }\n    return 'main';\n  });\n  const [tutorialMode, setTutorialMode] = useState<'chain-reaction' | 'base-reaction'>('chain-reaction');\n  const [selectedMode, setSelectedMode] = useState<'chain-reaction' | 'base-reaction'>(() => {\n    if (navigationState?.selectedMode) {\n      return navigationState.selectedMode;\n    }\n    return 'chain-reaction';\n  });\n  const [aiStrategy, setAIStrategy] = useState<AI_STRATEGY>(AI_STRATEGY.SMART);\n  \n  // Initialize number of players from existing settings\n  const initialNumPlayers = (): 2 | 3 | 4 => {\n    const settings = PlayerSettingsManager.getSettings();\n    return settings.numberOfPlayers;\n  };\n  \n  const [numPlayers, setNumPlayers] = useState<2 | 3 | 4>(initialNumPlayers());\n  \n  // Get initial player configurations\n  const initialSettings = PlayerSettingsManager.getSettings();\n  const [playerConfigs, setPlayerConfigs] = useState<PlayerConfig[]>(\n    initialSettings.playerConfigs || createDefaultPlayerConfigs(playerAssignments[numPlayers])\n  );\n  \n  // Update player configurations when number of players changes\n  const handleNumPlayersChange = (num: 2 | 3 | 4) => {\n    setNumPlayers(num);\n    \n    // Get the current player colors for the new number of players\n    const newPlayerColors = playerAssignments[num];\n    \n    // Create new player configs - all human players for multiplayer\n    const newPlayerConfigs = newPlayerColors.map(player => {\n      // All players are human in multiplayer mode\n      return {\n        player,\n        control: PLAYER_CONTROL.HUMAN,\n        aiStrategy: undefined\n      };\n    });\n    \n    setPlayerConfigs(newPlayerConfigs);\n  };\n  \n  // Setup singleplayer game (human vs AI)\n  const setupSingleplayer = (strategy: AI_STRATEGY) => {\n    // Create a config with just 2 players (red human, blue AI)\n    const singleplayerConfig = [\n      {\n        player: PLAYER.RED,\n        control: PLAYER_CONTROL.HUMAN,\n        aiStrategy: undefined\n      },\n      {\n        player: PLAYER.BLUE,\n        control: PLAYER_CONTROL.AI,\n        aiStrategy: strategy\n      }\n    ];\n    \n    // Force number of players to 2 for singleplayer\n    setNumPlayers(2);\n    setPlayerConfigs(singleplayerConfig);\n    \n    // Save and start the game with singleplayer settings\n    setPlayerSettings({\n      numberOfPlayers: 2,\n      players: [PLAYER.RED, PLAYER.BLUE],\n      playerConfigs: singleplayerConfig\n    });\n    \n    // Navigate to selected game mode\n    navigate(`/${selectedMode}`);\n  };\n  \n  // Toggle player control between human and AI (now enabled in multiplayer mode)\n  const togglePlayerControl = (player: PLAYER) => {\n    console.log('Toggling player control for:', player);\n    \n    const updatedConfigs = [...playerConfigs];\n    const playerIndex = updatedConfigs.findIndex(config => config.player === player);\n    \n    if (playerIndex !== -1) {\n      const currentControl = updatedConfigs[playerIndex].control;\n      \n      if (currentControl === PLAYER_CONTROL.HUMAN) {\n        updatedConfigs[playerIndex].control = PLAYER_CONTROL.AI;\n        updatedConfigs[playerIndex].aiStrategy = aiStrategy;\n      } else {\n        updatedConfigs[playerIndex].control = PLAYER_CONTROL.HUMAN;\n        updatedConfigs[playerIndex].aiStrategy = undefined;\n      }\n    }\n    \n    setPlayerConfigs(updatedConfigs);\n  };\n  \n  // Save settings and start the game\n  const saveAndStartGame = () => {\n    // Save player settings\n    setPlayerSettings({\n      numberOfPlayers: numPlayers,\n      players: playerAssignments[numPlayers],\n      playerConfigs: playerConfigs\n    });\n    \n    // Navigate to selected game mode\n    navigate(`/${selectedMode}`);\n  };\n  \n  // Button style for consistent UI - all buttons same height and quick animations\n  const buttonStyle = {\n    base: \"py-4 px-6 rounded-xl text-white text-base transition-all duration-100 border-2 border-white w-full h-14 flex items-center justify-center\",\n    primary: \"bg-black hover:bg-gray-800\",\n    selected: \"bg-white text-black hover:bg-gray-200\",\n    back: \"py-4 px-6 rounded-xl text-white text-base border-2 border-white hover:bg-gray-800 transition-all duration-100 w-full h-14 flex items-center justify-center\",\n  };\n  \n  return (\n    <div className=\"flex flex-col items-center justify-center min-h-screen bg-black text-white p-4 pt-20 md:pt-24\">\n      {/* Fixed position title - responsive sizing, moved lower */}\n      <div className=\"fixed top-16 md:top-24 left-0 right-0 z-10\">\n        <motion.h1 \n          initial={{ y: -20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ duration: 0.5 }}\n          className=\"text-3xl md:text-6xl font-bold text-center text-white mb-4\" \n          style={{ fontFamily: 'Menlo, monospace' }}\n        >\n          Base Reaction\n        </motion.h1>\n      </div>\n      \n      {/* Main Menu Screen */}\n      {menuScreen === 'main' && (\n        <motion.div \n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          transition={{ duration: 0.3 }}\n          className=\"bg-black p-6 md:p-8 w-full max-w-sm md:w-80\"\n        >\n          <div className=\"grid grid-cols-1 gap-4 w-full\">\n\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => {\n                setSelectedMode('base-reaction');\n                setMenuScreen('multiplayer');\n              }}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Base Reaction\n            </motion.button>\n\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => {\n                setSelectedMode('chain-reaction');\n                setMenuScreen('multiplayer');\n              }}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Chain Reaction\n            </motion.button>\n\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => setMenuScreen('tutorial')}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Tutorial\n            </motion.button>\n            \n          </div>\n        </motion.div>\n      \n      )}\n      \n      {/* Game Mode Selection Screen */}\n      {menuScreen === 'mode' && (\n        <motion.div \n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n          className=\"bg-black p-6 md:p-8 w-full max-w-sm md:w-80\"\n        >\n          <h2 className=\"text-xl font-bold mb-4 text-center\" style={{ fontFamily: 'Menlo, monospace' }}>\n            {selectedMode === 'chain-reaction' ? 'Chain Reaction Mode' : 'Base Reaction Mode'}\n          </h2>\n          \n          <div className=\"grid grid-cols-1 gap-3 mb-4\">\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => setMenuScreen('singleplayer')}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Singleplayer\n            </motion.button>\n            \n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => setMenuScreen('multiplayer')}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Multiplayer\n            </motion.button>\n          </div>\n          \n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.1 }}\n            onClick={() => setMenuScreen('main')}\n            className={`${buttonStyle.back}`}\n            style={{ fontFamily: 'Menlo, monospace' }}\n          >\n            Back\n          </motion.button>\n        </motion.div>\n      )}\n      \n      {/* Singleplayer Difficulty Selection */}\n      {menuScreen === 'singleplayer' && (\n        <motion.div \n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n          className=\"bg-black p-8 w-80\"\n        >\n          <h2 className=\"text-2xl font-bold mb-2 text-center\" style={{ fontFamily: 'Menlo, monospace' }}>\n            Select AI Strategy\n          </h2>\n          <p className=\"text-sm text-gray-400 mb-4 text-center\">\n            Choose between two advanced AI systems to challenge yourself\n          </p>\n          \n          <div className=\"grid grid-cols-1 gap-4 mb-6\">\n            <motion.button\n              whileHover={{ scale: 1.02 }}\n              whileTap={{ scale: 0.98 }}\n              onClick={() => setupSingleplayer(AI_STRATEGY.SMART)}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              <div className=\"text-left\">\n                <div className=\"font-bold\">Play vs AI</div>\n                <div className=\"text-xs text-gray-300\">Strategic AI opponent</div>\n              </div>\n            </motion.button>\n          </div>\n          \n          <motion.button\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={() => setMenuScreen('mode')}\n            className={`${buttonStyle.back} w-full text-center`}\n            style={{ fontFamily: 'Menlo, monospace' }}\n          >\n            Back\n          </motion.button>\n        </motion.div>\n      )}\n      \n      {/* Tutorial Selection Screen */}\n      {menuScreen === 'tutorial' && (\n        <motion.div \n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n          className=\"bg-black p-8 w-80\"\n        >\n          <h2 className=\"text-2xl font-bold mb-6 text-center\" style={{ fontFamily: 'Menlo, monospace' }}>\n            Select Tutorial\n          </h2>\n          \n          <div className=\"grid grid-cols-1 gap-4 mb-6\">\n            <motion.button\n              whileHover={{ scale: 1.02 }}\n              whileTap={{ scale: 0.98 }}\n              onClick={() => {\n                setTutorialMode('chain-reaction');\n                setMenuScreen('tutorial-content');\n              }}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Chain Reaction \n            </motion.button>\n            \n            <motion.button\n              whileHover={{ scale: 1.02 }}\n              whileTap={{ scale: 0.98 }}\n              onClick={() => {\n                setTutorialMode('base-reaction');\n                setMenuScreen('tutorial-content');\n              }}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Base Reaction\n            </motion.button>\n          </div>\n          \n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            transition={{ duration: 0.1 }}\n            onClick={() => setMenuScreen('main')}\n            className={`${buttonStyle.back}`}\n            style={{ fontFamily: 'Menlo, monospace' }}\n          >\n            Back\n          </motion.button>\n        </motion.div>\n      )}\n      \n      {/* Tutorial Content */}\n      {menuScreen === 'tutorial-content' && (\n        <div className=\"w-full max-w-3xl mt-20 md:mt-24\"> {/* Add more top margin to avoid overlaying title */}\n          <TutorialScreen mode={tutorialMode} onBack={() => setMenuScreen('tutorial')} />\n        </div>\n      )}\n      \n      {/* Multiplayer Setup */}\n      {menuScreen === 'multiplayer' && (\n        <motion.div \n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ duration: 0.3 }}\n          className=\"bg-black p-4 w-full max-w-xs mx-auto\"\n        >\n          <div className=\"mb-4\">\n            <h3 className=\"text-lg font-semibold mb-2\" style={{ fontFamily: 'Menlo, monospace' }}>Number of Players</h3>\n            <div className=\"grid grid-cols-3 gap-2\">\n              {[2, 3, 4].map((num) => (\n                <motion.button\n                  key={num}\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  transition={{ duration: 0.1 }}\n                  onClick={() => handleNumPlayersChange(num as 2 | 3 | 4)}\n                  className={`h-12 px-3 rounded-xl border-2 border-white text-lg transition-all duration-100 flex items-center justify-center ${\n                    numPlayers === num \n                      ? 'bg-white text-black hover:bg-gray-200'\n                      : 'bg-black hover:bg-gray-800 text-white'\n                  }`}\n                  style={{ fontFamily: 'Menlo, monospace' }}\n                >\n                  {num}\n                </motion.button>\n              ))}\n            </div>\n          </div>\n          \n\n\n          <div className=\"mb-4\">\n            <h3 className=\"text-lg font-semibold mb-2 text-center\" style={{ fontFamily: 'Menlo, monospace' }}>Players</h3>\n            <div className=\"flex justify-center\">\n              <div className=\"grid grid-cols-4 gap-2 w-fit\">\n              {playerConfigs.map((config) => (\n                <motion.div \n                  key={config.player} \n                  className={`w-14 h-14 rounded-full cursor-pointer relative ${config.player === PLAYER.BLACK ? 'border-2 border-white' : ''}`}\n                  style={{ \n                    backgroundColor: PLAYER_COLORS[config.player]\n                  }}\n                  whileHover={{ scale: 1.1 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={() => togglePlayerControl(config.player)}\n                >\n                  <div className=\"absolute inset-0 flex items-center justify-center\">\n                    {config.control === PLAYER_CONTROL.HUMAN ? (\n                      <img \n                        src=\"/icons/human_icon.png\" \n                        alt=\"Human\" \n                        className=\"w-7 h-7\"\n                        loading=\"eager\"\n                        decoding=\"sync\"\n                      />\n                    ) : (\n                      <img \n                        src=\"/icons/AI_icon.png\" \n                        alt=\"AI\" \n                        className=\"w-7 h-7\"\n                        loading=\"eager\"\n                        decoding=\"sync\"\n                      />\n                    )}\n                  </div>\n                </motion.div>\n              ))}\n              </div>\n            </div>\n          </div>\n          \n          <div className=\"grid grid-cols-1 gap-4\">\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={saveAndStartGame}\n              className={`${buttonStyle.base} ${buttonStyle.primary}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Start Game\n            </motion.button>\n            \n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              transition={{ duration: 0.1 }}\n              onClick={() => setMenuScreen('main')}\n              className={`${buttonStyle.back}`}\n              style={{ fontFamily: 'Menlo, monospace' }}\n            >\n              Back\n            </motion.button>\n          </div>\n        </motion.div>\n      )}\n    </div>\n  );\n};\n\nexport default MainMenu;\n","size_bytes":21037},"client/src/components/Menu/TutorialScreen.tsx":{"content":"import React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { motion } from \"framer-motion\";\n\ninterface TutorialScreenProps {\n  mode: \"chain-reaction\" | \"base-reaction\";\n  onBack?: () => void; // Optional callback to handle back navigation\n}\n\nconst typewriterFont = { fontFamily: 'Menlo, monospace' };\n\nconst TutorialScreen: React.FC<TutorialScreenProps> = ({ mode, onBack }) => {\n  const navigate = useNavigate();\n  \n  return (\n    <div className=\"min-h-screen bg-black p-4 py-8\" style={{ maxHeight: \"100vh\" }}>\n      <h1 className=\"text-2xl md:text-3xl font-bold mb-6 text-center text-white\" style={typewriterFont}>\n        {mode === \"chain-reaction\" ? \"Chain Reaction Mode\" : \"Base Reaction Mode\"} Tutorial\n      </h1>\n      <div className=\"max-w-3xl mx-auto text-white p-4 md:p-6\" style={{ transition: \"all 0.3s ease\" }}>\n        \n        {mode === \"chain-reaction\" ? (\n          <div className=\"space-y-4\">\n            <section>\n              <h2 className=\"text-lg font-semibold mb-2\" style={typewriterFont}>How to Play</h2>\n              <ul className=\"list-disc pl-6 space-y-1\" style={typewriterFont}>\n                <li>Win by being the only player with dots remaining</li>\n                <li>Click empty cells or your own colored cells to add dots</li>\n                <li>When cells get too full, they explode and spread to neighbors, creating chain reactions</li>\n                \n              </ul>\n            </section>\n            \n            <section>\n              <h2 className=\"text-lg font-semibold mb-2\" style={typewriterFont}>Critical Mass (When Cells Explode)</h2>\n              <ul className=\"list-disc pl-6 space-y-1\" style={typewriterFont}>\n                <li><strong>Corner cells:</strong> 2 dots â†’ explode</li>\n                <li><strong>Edge cells:</strong> 3 dots â†’ explode</li>\n                <li><strong>Center cells:</strong> 4 dots â†’ explode</li>\n              </ul>\n            </section>\n            \n\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            <section>\n              <h2 className=\"text-lg font-semibold mb-2\" style={typewriterFont}>How to Play</h2>\n              <ul className=\"list-disc pl-6 space-y-1\" style={typewriterFont}>\n                <li>Win by being the last player with an HQ</li>\n                <li>You can only place dots near your HQ, on the line that your HQ is on or next to your existing dots</li>\n                <li>Exploding next to enemy HQs damages them</li>\n              </ul>\n            </section>\n            \n            <section>\n              <h2 className=\"text-lg font-semibold mb-2\" style={typewriterFont}>Power-ups</h2>\n              <ul className=\"list-disc pl-6 space-y-1\" style={typewriterFont}>\n                <li>\n                  <strong>Diamond:</strong> When a player places a dot on a diamond, a 3Ã—3 grid of cells centered on the diamond gets one dot of the player's color added to each cell (only applies to empty cells or cells with the player's color).\n                </li>\n                <li>\n                  <strong>Heart:</strong> The player's HQ gains one life (up to a maximum of 5). In 3-4 player games, hearts never damage enemy HQs.\n                </li>\n              </ul>\n            </section>\n          </div>\n        )}\n        \n        <div className=\"mt-8 mb-16 flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4\">\n          <motion.button\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={() => {\n              if (onBack) {\n                onBack(); // Use callback if provided (when accessed from MainMenu)\n              } else {\n                navigate(\"/\"); // Fallback to home navigation\n              }\n            }}\n            className=\"py-4 px-8 rounded-2xl text-white bg-black hover:bg-gray-800 transition-all duration-200 border-2 border-white w-full md:w-auto\"\n            style={typewriterFont}\n          >\n            Back\n          </motion.button>\n          \n    \n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TutorialScreen;\n","size_bytes":4124},"client/src/lib/stores/useAudio.tsx":{"content":"import { create } from \"zustand\";\n\ninterface AudioState {\n  backgroundMusic: HTMLAudioElement | null;\n  hitSound: HTMLAudioElement | null;\n  successSound: HTMLAudioElement | null;\n  isMuted: boolean;\n  \n  // Setter functions\n  setBackgroundMusic: (music: HTMLAudioElement) => void;\n  setHitSound: (sound: HTMLAudioElement) => void;\n  setSuccessSound: (sound: HTMLAudioElement) => void;\n  \n  // Control functions\n  toggleMute: () => void;\n  playHit: () => void;\n  playSuccess: () => void;\n}\n\nexport const useAudio = create<AudioState>((set, get) => ({\n  backgroundMusic: null,\n  hitSound: null,\n  successSound: null,\n  isMuted: false, // Start with sound enabled\n  \n  setBackgroundMusic: (music) => set({ backgroundMusic: music }),\n  setHitSound: (sound) => set({ hitSound: sound }),\n  setSuccessSound: (sound) => set({ successSound: sound }),\n  \n  toggleMute: () => {\n    const { isMuted } = get();\n    const newMutedState = !isMuted;\n    \n    // Just update the muted state\n    set({ isMuted: newMutedState });\n    \n    // Log the change\n    console.log(`Sound ${newMutedState ? 'muted' : 'unmuted'}`);\n  },\n  \n  playHit: () => {\n    const { hitSound, isMuted } = get();\n    if (hitSound) {\n      // If sound is muted, don't play anything\n      if (isMuted) {\n        console.log(\"Hit sound skipped (muted)\");\n        return;\n      }\n      \n      // Clone the sound to allow overlapping playback\n      const soundClone = hitSound.cloneNode() as HTMLAudioElement;\n      soundClone.volume = 0.3;\n      soundClone.play().catch(error => {\n        console.log(\"Hit sound play prevented:\", error);\n      });\n    }\n  },\n  \n  playSuccess: () => {\n    const { successSound, isMuted } = get();\n    if (successSound) {\n      // If sound is muted, don't play anything\n      if (isMuted) {\n        console.log(\"Success sound skipped (muted)\");\n        return;\n      }\n      \n      successSound.currentTime = 0;\n      successSound.play().catch(error => {\n        console.log(\"Success sound play prevented:\", error);\n      });\n    }\n  }\n}));\n","size_bytes":2028},"client/src/lib/stores/useChainReaction.tsx":{"content":"import { create } from \"zustand\";\nimport { PLAYER } from \"../constants\";\nimport { PlayerSettingsManager, playerAssignments } from \"../../components/Menu/MainMenu\";\n\nexport type GridCell = {\n  atoms: number;\n  player: PLAYER | null;\n};\n\nexport type PowerUpType = 'diamond' | 'heart' | null;\n\nexport type PowerUpCell = {\n  row: number;\n  col: number;\n  type: PowerUpType;\n};\n\nexport type HQCell = {\n  row: number;\n  col: number;\n  player: PLAYER;\n  health: number;\n};\n\nexport type GameHistory = {\n  grid: GridCell[][];\n  currentPlayer: PLAYER;\n  gameOver: boolean;\n  winner: PLAYER | null;\n  baseMode?: {\n    hqs: HQCell[];\n    powerUps: PowerUpCell[];\n  };\n};\n\n// HQ effect tracking (damage, healing, or destruction)\ntype HQDamageEffect = {\n  row: number;\n  col: number;\n  player: PLAYER;\n  timestamp: number;\n  type: 'damage' | 'heal' | 'destroyed'; // Indicates whether the HQ lost, gained health, or was destroyed\n};\n\ninterface ChainReactionState {\n  // Game state\n  isBaseMode: boolean;\n  grid: GridCell[][];\n  rows: number;\n  cols: number;\n  currentPlayer: PLAYER;\n  gameOver: boolean;\n  winner: PLAYER | null;\n\n  // Animation state\n  animating: boolean;\n  setAnimating: (animating: boolean) => void;\n  \n  // Visual effects state\n  lastHQDamaged?: HQDamageEffect;\n\n  // Base mode specific\n  hqs: HQCell[];\n  powerUps: PowerUpCell[];\n\n  // Heart power-up selection mode\n  heartSelectionMode: boolean;\n  pendingHeartPlayer: PLAYER | null;\n\n  // History for undo\n  history: GameHistory[];\n\n  // Game actions\n  initClassicMode: () => void;\n  initBaseMode: () => void;\n  placeDot: (row: number, col: number) => void;\n  undo: () => void;\n  restart: () => void;\n  isValidMove: (row: number, col: number) => boolean; // This is explicitly a boolean return\n\n\n  // Utilities\n  getCriticalMass: (row: number, col: number) => number;\n  getNeighbors: (row: number, col: number) => { row: number; col: number }[];\n}\n\nexport const useChainReaction = create<ChainReactionState>((set, get) => ({\n  // Default initial state\n  isBaseMode: false,\n  grid: [],\n  rows: 7,\n  cols: 9,\n  currentPlayer: PLAYER.RED,\n  gameOver: false,\n  winner: null,\n\n  // Animation state\n  animating: false,\n  setAnimating: (animating) => set({ animating }),\n\n  // Base mode specific\n  hqs: [],\n  powerUps: [],\n\n  // Heart power-up selection mode\n  heartSelectionMode: false,\n  pendingHeartPlayer: null,\n\n\n\n  // History for undo\n  history: [],\n\n  // Initialize classic mode (9x7 grid - more vertical)\n  initClassicMode: () => {\n    // Clear grid immediately to prevent visual glitch\n    set({\n      grid: [],\n      gameOver: false,\n      winner: null,\n      history: [],\n      hqs: [],\n      powerUps: [],\n    });\n\n    const rows = 9;\n    const cols = 7;\n\n    // Create a properly typed grid\n    const emptyGrid: GridCell[][] = [];\n    for (let r = 0; r < rows; r++) {\n      const row: GridCell[] = [];\n      for (let c = 0; c < cols; c++) {\n        row.push({ atoms: 0, player: null });\n      }\n      emptyGrid.push(row);\n    }\n\n    // Determine starting player from player settings\n    let startingPlayer = PLAYER.RED;\n    \n    // Use PlayerSettingsManager to get player settings\n    try {\n      // Get settings using the manager\n      const settings = PlayerSettingsManager.getSettings();\n      const activePlayers = settings.players;\n      \n      // Ensure we have valid players\n      if (activePlayers && activePlayers.length > 0) {\n        startingPlayer = activePlayers[0];\n        console.log(\"Using player settings for classic mode:\", settings);\n      } else {\n        console.log(\"No valid player settings found, using defaults for classic mode\");\n      }\n    } catch (error) {\n      console.log(\"Error getting player settings for classic mode:\", error);\n    }\n    \n    // Get the active player list from PlayerSettingsManager for logging\n    const activePlayersList = PlayerSettingsManager.getSettings().players;\n    console.log(`Initializing classic mode with players:`, activePlayersList, `starting with ${startingPlayer}`);\n\n    set({\n      isBaseMode: false,\n      grid: emptyGrid,\n      rows,\n      cols,\n      currentPlayer: startingPlayer,\n      gameOver: false,\n      winner: null,\n      history: [], // Clear history\n      hqs: [], // No HQs in classic mode\n      powerUps: [], // No power-ups in classic mode\n    });\n  },\n\n  // Initialize base reaction mode (9x9 grid with HQs)\n  initBaseMode: () => {\n    // Clear grid immediately to prevent visual glitch\n    set({\n      grid: [],\n      gameOver: false,\n      winner: null,\n      history: [],\n      hqs: [],\n      powerUps: [],\n    });\n\n    const rows = 9;\n    const cols = 9;\n\n    // Create a properly typed grid\n    const emptyGrid: GridCell[][] = [];\n    for (let r = 0; r < rows; r++) {\n      const row: GridCell[] = [];\n      for (let c = 0; c < cols; c++) {\n        row.push({ atoms: 0, player: null });\n      }\n      emptyGrid.push(row);\n    }\n\n    // Get player settings to set up HQs for selected players\n    let activePlayers = [PLAYER.RED, PLAYER.BLUE]; // Default\n    let numPlayers = 2;\n    \n    try {\n      // Get settings using the PlayerSettingsManager\n      const settings = PlayerSettingsManager.getSettings();\n      \n      // Ensure we have valid players\n      if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n        activePlayers = settings.players;\n        numPlayers = settings.numberOfPlayers || activePlayers.length;\n        console.log(\"Using player settings for base mode:\", settings);\n      } else {\n        console.log(\"No valid player settings found, using defaults for base mode\");\n      }\n    } catch (error) {\n      console.log(\"Error getting player settings for base mode:\", error);\n    }\n    \n    // Ensure numPlayers matches activePlayers.length\n    numPlayers = Math.min(numPlayers, 4); // Cap at 4\n    console.log(`Initializing base mode with ${numPlayers} players:`, activePlayers);\n\n    // Create HQ cells based on the number of players\n    const hqs: HQCell[] = [];\n    \n    if (numPlayers === 2) {\n      // Traditional 2-player setup (left and right)\n      const player1 = activePlayers[0]; // RED - Left\n      const player2 = activePlayers[1]; // BLUE - Right\n      \n      hqs.push({ row: Math.floor(rows / 2), col: 0, player: player1, health: 5 });  // Left\n      hqs.push({ row: Math.floor(rows / 2), col: cols - 1, player: player2, health: 5 });  // Right\n    } \n    else if (numPlayers === 3) {\n      // 3-player setup in clockwise order: RED, BLUE, VIOLET\n      // Position at Left, Top, Right in clockwise order\n      const player1 = activePlayers[0]; // RED - Left\n      const player2 = activePlayers[1]; // BLUE - Top\n      const player3 = activePlayers[2]; // VIOLET - Right\n      \n      hqs.push({ row: Math.floor(rows / 2), col: 0, player: player1, health: 5 });  // Left - RED\n      hqs.push({ row: 0, col: Math.floor(cols / 2), player: player2, health: 5 });  // Top - BLUE\n      hqs.push({ row: Math.floor(rows / 2), col: cols - 1, player: player3, health: 5 });  // Right - VIOLET\n    }\n    else if (numPlayers === 4) {\n      // 4-player setup in clockwise order: RED, BLUE, VIOLET, DARK_BLUE\n      // Position at Left, Top, Right, Bottom in clockwise order\n      const player1 = activePlayers[0]; // RED - Left\n      const player2 = activePlayers[1]; // BLUE - Top\n      const player3 = activePlayers[2]; // VIOLET - Right\n      const player4 = activePlayers[3]; // DARK_BLUE - Bottom\n      \n      hqs.push({ row: Math.floor(rows / 2), col: 0, player: player1, health: 5 });  // Left - RED\n      hqs.push({ row: 0, col: Math.floor(cols / 2), player: player2, health: 5 });  // Top - BLUE\n      hqs.push({ row: Math.floor(rows / 2), col: cols - 1, player: player3, health: 5 });  // Right - VIOLET\n      hqs.push({ row: rows - 1, col: Math.floor(cols / 2), player: player4, health: 5 });  // Bottom - DARK_BLUE\n    }\n\n    // Place HQ cells on the grid with initial atoms\n    hqs.forEach(hq => {\n      emptyGrid[hq.row][hq.col] = {\n        atoms: 1,\n        player: hq.player\n      };\n    });\n\n    // Start with no power-ups - they'll be generated on the second turn\n    const powerUps: PowerUpCell[] = [];\n\n    // Determine starting player\n    let startingPlayer = activePlayers[0];\n\n    set({\n      isBaseMode: true,\n      grid: emptyGrid,\n      rows,\n      cols,\n      currentPlayer: startingPlayer,\n      gameOver: false,\n      winner: null,\n      history: [], // Clear history\n      hqs: hqs, // Set HQs based on player selection\n      powerUps, // Empty power-ups initially\n      lastHQDamaged: undefined // Clear any previous HQ damage animations to prevent startup animations\n    });\n  },\n\n  // Calculate critical mass for a cell\n  getCriticalMass: (row, col) => {\n    const { rows, cols } = get();\n\n    // Corner cells (2 neighbors)\n    if ((row === 0 && col === 0) || \n        (row === 0 && col === cols - 1) || \n        (row === rows - 1 && col === 0) || \n        (row === rows - 1 && col === cols - 1)) {\n      return 2;\n    }\n\n    // Edge cells (3 neighbors)\n    if (row === 0 || row === rows - 1 || col === 0 || col === cols - 1) {\n      return 3;\n    }\n\n    // Center cells (4 neighbors)\n    return 4;\n  },\n\n  // Get neighboring cells\n  getNeighbors: (row, col) => {\n    const { rows, cols } = get();\n    const neighbors = [];\n\n    // Check up\n    if (row > 0) neighbors.push({ row: row - 1, col });\n    // Check right\n    if (col < cols - 1) neighbors.push({ row, col: col + 1 });\n    // Check down\n    if (row < rows - 1) neighbors.push({ row: row + 1, col });\n    // Check left\n    if (col > 0) neighbors.push({ row, col: col - 1 });\n\n    return neighbors;\n  },\n\n  // Check if a move is valid\n  isValidMove: (row, col) => {\n    const { grid, currentPlayer, gameOver, isBaseMode, hqs } = get();\n\n    // No moves if game is over\n    if (gameOver) return false;\n\n    // Safety check for valid coordinates\n    if (row < 0 || col < 0 || row >= grid.length || col >= grid[0].length) {\n      return false;\n    }\n\n    const cell = grid[row][col];\n\n    // In classic mode, a move is valid if the cell is empty or owned by the current player\n    if (!isBaseMode) {\n      return cell.player === null || cell.player === currentPlayer;\n    }\n\n    // In base mode, additional rules apply\n\n    // RULE 1: Cannot place on any HQ base (even your own)\n    const isAnyHQ = hqs.some(hq => hq.row === row && hq.col === col);\n    if (isAnyHQ) return false;\n\n    // RULE 2: Can play on empty cells or your own cells\n    if (cell.player === null || cell.player === currentPlayer) {\n      // Find current player's HQ\n      const ownHQ = hqs.find(hq => hq.player === currentPlayer);\n\n      if (!ownHQ) return false; // Safety check\n\n      // RULE 3: Check if in the side of the HQ (row OR column, determined by HQ position)\n      // This allows for \"line of sight\" expansion only on their own side\n      let isInHQLine = false;\n\n      // Determine which side the player's HQ is on\n      if (ownHQ.col === 0) {\n        // HQ is on left, player can only place on their column\n        isInHQLine = col === ownHQ.col;\n      } else if (ownHQ.col === grid[0].length - 1) {\n        // HQ is on right, player can only place on their column\n        isInHQLine = col === ownHQ.col;\n      } else if (ownHQ.row === 0) {\n        // HQ is on top, player can only place on their row\n        isInHQLine = row === ownHQ.row;\n      } else if (ownHQ.row === grid.length - 1) {\n        // HQ is on bottom, player can only place on their row\n        isInHQLine = row === ownHQ.row;\n      } else {\n        // Safety fallback for unexpected HQ positions\n        console.warn(\"HQ position not on grid edge, allowing both row and column\");\n        isInHQLine = (row === ownHQ.row || col === ownHQ.col);\n      }\n\n      // RULE 4: Check if there are orthogonal neighboring cells of your color\n      // This allows for expanding from existing dots\n      const neighbors = get().getNeighbors(row, col);\n      const hasOwnNeighbor = neighbors.some(n => {\n        if (n.row < 0 || n.row >= grid.length || n.col < 0 || n.col >= grid[0].length) return false;\n        const neighborCell = grid[n.row][n.col];\n        return neighborCell.player === currentPlayer;\n      });\n\n      // RULE 5: Check diagonal neighbors as well\n      // This allows for expanding diagonally from existing dots\n      const diagonalNeighbors = [\n        {row: row-1, col: col-1}, {row: row-1, col: col+1},\n        {row: row+1, col: col-1}, {row: row+1, col: col+1}\n      ].filter(n => n.row >= 0 && n.row < grid.length && n.col >= 0 && n.col < grid[0].length);\n\n      const hasOwnDiagonalNeighbor = diagonalNeighbors.some(n => {\n        const neighborCell = grid[n.row][n.col];\n        return neighborCell.player === currentPlayer;\n      });\n\n      // RULE 6: Check if adjacent to HQ (including diagonal)\n      // This allows for expanding immediately around your own HQ\n      // Ensure we exclude the HQ cell itself more precisely\n      const isAdjacentToHQ = (\n        Math.abs(ownHQ.row - row) <= 1 && \n        Math.abs(ownHQ.col - col) <= 1 && \n        !(ownHQ.row === row && ownHQ.col === col) // Explicitly exclude HQ cell itself\n      );\n\n      // Debug logging for all players\n      console.log(`${currentPlayer} player - Cell ${row},${col} check:\n        - Is in HQ line (row or column): ${isInHQLine}\n        - Has orthogonal neighbor: ${hasOwnNeighbor}\n        - Has diagonal neighbor: ${hasOwnDiagonalNeighbor}\n        - Is adjacent to HQ: ${isAdjacentToHQ}`);\n\n      // Valid move if any of the following is true:\n      // 1. In same line as HQ (row OR column depending on HQ position)\n      // 2. Adjacent to HQ (including diagonal)\n      // 3. Adjacent (orthogonal) to own piece\n      // 4. Adjacent (diagonal) to own piece\n      return isInHQLine || isAdjacentToHQ || hasOwnNeighbor || hasOwnDiagonalNeighbor;\n    }\n\n    return false;\n  },\n\n  // Place a dot on the board\n  placeDot: (row, col) => {\n    const { \n      grid, currentPlayer, isBaseMode, \n      getCriticalMass, getNeighbors, \n      powerUps, hqs, setAnimating, \n      heartSelectionMode, pendingHeartPlayer\n    } = get();\n\n    console.log(`Placing dot at (${row},${col}) for player ${currentPlayer}`);\n\n    // ROCK-SOLID HEART SELECTION LOGIC\n    if (heartSelectionMode) {\n      console.log(`ðŸŽ¯ HEART SELECTION: Player ${currentPlayer} clicked (${row},${col})`);\n      \n      // Find all HQs and log them\n      const allHQs = hqs;\n      console.log(`All HQs on board:`, allHQs);\n      \n      // Find the HQ at clicked position\n      const clickedHQ = allHQs.find(hq => hq.row === row && hq.col === col);\n      console.log(`Clicked HQ:`, clickedHQ);\n      \n      // Check if it's a valid enemy target\n      const isValidTarget = clickedHQ && clickedHQ.player !== currentPlayer;\n      console.log(`Is valid enemy target:`, isValidTarget);\n      \n      if (isValidTarget) {\n        console.log(`âœ… DAMAGING ENEMY: ${clickedHQ.player} (health: ${clickedHQ.health} -> ${clickedHQ.health - 1})`);\n        \n        // Simple next player calculation\n        const nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : \n                          currentPlayer === PLAYER.BLUE ? PLAYER.VIOLET : \n                          currentPlayer === PLAYER.VIOLET ? PLAYER.BLACK : PLAYER.RED;\n        \n        // Update everything in one atomic operation\n        const newHqs = hqs.map(hq => \n          hq.row === row && hq.col === col \n            ? { ...hq, health: hq.health - 1 }\n            : hq\n        );\n        \n        set({\n          ...get(),\n          hqs: newHqs,\n          heartSelectionMode: false,\n          pendingHeartPlayer: null,\n          currentPlayer: nextPlayer,\n          lastHQDamaged: {\n            row: row,\n            col: col,\n            player: clickedHQ.player,\n            timestamp: Date.now(),\n            type: 'damage' as const\n          }\n        });\n        \n        console.log(`ðŸŽ¯ HEART DAMAGE COMPLETE! Next player: ${nextPlayer}`);\n        return;\n      } else {\n        console.log(`âŒ CANCELLING HEART SELECTION (invalid target)`);\n        \n        // Cancel selection and advance turn\n        const nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : \n                          currentPlayer === PLAYER.BLUE ? PLAYER.VIOLET : \n                          currentPlayer === PLAYER.VIOLET ? PLAYER.BLACK : PLAYER.RED;\n        \n        set({\n          ...get(),\n          heartSelectionMode: false,\n          pendingHeartPlayer: null,\n          currentPlayer: nextPlayer\n        });\n        \n        console.log(`ðŸŽ¯ HEART SELECTION CANCELLED! Next player: ${nextPlayer}`);\n        return;\n      }\n    }\n\n    // Save current state to history before making changes\n    const currentState = get();\n    const historyEntry: GameHistory = {\n      grid: JSON.parse(JSON.stringify(currentState.grid)),\n      currentPlayer: currentState.currentPlayer,\n      gameOver: currentState.gameOver,\n      winner: currentState.winner\n    };\n\n    if (isBaseMode) {\n      historyEntry.baseMode = {\n        hqs: JSON.parse(JSON.stringify(currentState.hqs)),\n        powerUps: JSON.parse(JSON.stringify(currentState.powerUps))\n      };\n    }\n\n    set(state => ({\n      history: [...state.history, historyEntry]\n    }));\n\n    // Process the move\n    set(state => {\n      // Create a deep copy of the grid to avoid direct state mutations\n      const newGrid = JSON.parse(JSON.stringify(state.grid));\n      let newHqs = [...state.hqs];\n      // Create a new copy of power-ups for modification\n      let newPowerUps = [...state.powerUps];\n\n      // Check if the cell has a power-up\n      const powerUpIndex = newPowerUps.findIndex(pu => pu.row === row && pu.col === col);\n      const powerUp = powerUpIndex !== -1 ? newPowerUps[powerUpIndex] : null;\n\n      if (powerUp && powerUp.type === 'diamond') {\n        // Check number of players to determine power-up behavior\n        try {\n          const settings = PlayerSettingsManager.getSettings();\n          const numPlayers = settings.numberOfPlayers || 2;\n          \n          if (numPlayers >= 3) {\n            // 3-4 player game: Diamond spawns dots in a 3x3 area around the clicked cell\n            console.log(\"Diamond power-up in 3-4 player game: spawning dots in 3x3 area\");\n            \n            // Get all 9 cells in the 3x3 grid around the current cell\n            for (let r = row - 1; r <= row + 1; r++) {\n              for (let c = col - 1; c <= col + 1; c++) {\n                // Check if coordinates are valid (within grid bounds)\n                if (r >= 0 && r < state.rows && c >= 0 && c < state.cols) {\n                  // Place dot only if the cell is empty or belongs to the current player\n                  if (newGrid[r][c].player === null || newGrid[r][c].player === currentPlayer) {\n                    newGrid[r][c].atoms += 1;\n                    newGrid[r][c].player = currentPlayer;\n                  }\n                }\n              }\n            }\n          } else {\n            // 2-player game: Diamond adds a dot to each cell in the row\n            console.log(\"Diamond power-up in 2-player game: spawning dots in row\");\n            for (let c = 0; c < state.cols; c++) {\n              if (newGrid[row][c].player === null || newGrid[row][c].player === currentPlayer) {\n                newGrid[row][c].atoms += 1;\n                newGrid[row][c].player = currentPlayer;\n              }\n            }\n          }\n        } catch (error) {\n          console.error(\"Error determining player count for diamond power-up:\", error);\n          // Fallback to original behavior\n          for (let c = 0; c < state.cols; c++) {\n            if (newGrid[row][c].player === null || newGrid[row][c].player === currentPlayer) {\n              newGrid[row][c].atoms += 1;\n              newGrid[row][c].player = currentPlayer;\n            }\n          }\n        }\n        \n        // Remove the power-up after use\n        newPowerUps.splice(powerUpIndex, 1);\n      } else if (powerUp && powerUp.type === 'heart') {\n        // NEW HEART POWER-UP LOGIC\n        console.log(\"Heart power-up used!\");\n        \n        // Remove power-up first\n        newPowerUps.splice(powerUpIndex, 1);\n        \n        // Get own HQ\n        const ownHQ = newHqs.find(hq => hq.player === currentPlayer);\n        if (!ownHQ) {\n          console.error(\"No HQ found for current player\");\n          // Continue with normal game flow even if no HQ found\n        } else if (ownHQ.health < 5) {\n          // Case 1: Less than 5 health - heal yourself\n          console.log(\"Heart: Healing own HQ\");\n          ownHQ.health += 1;\n          \n          // Store the heal effect for animation\n          setTimeout(() => {\n            set(state => ({\n              ...state,\n              lastHQDamaged: {\n                row: ownHQ.row,\n                col: ownHQ.col,\n                player: ownHQ.player,\n                timestamp: Date.now(),\n                type: 'heal' as const\n              }\n            }));\n          }, 0);\n        } else {\n          // Case 2 & 3: 5 health - damage an enemy\n          const enemyHQs = newHqs.filter(hq => hq.player !== currentPlayer);\n          if (enemyHQs.length === 1) {\n            // Case 2: Only one enemy - damage automatically\n            const targetEnemy = enemyHQs[0];\n            console.log(`Heart: Auto-damaging single enemy ${targetEnemy.player}`);\n            targetEnemy.health -= 1;\n            \n            // Store the damage effect for animation\n            setTimeout(() => {\n              set(state => ({\n                ...state,\n                lastHQDamaged: {\n                  row: targetEnemy.row,\n                  col: targetEnemy.col,\n                  player: targetEnemy.player,\n                  timestamp: Date.now(),\n                  type: 'damage' as const\n                }\n              }));\n            }, 0);\n          } else if (enemyHQs.length > 1) {\n            // Case 3: Multiple enemies - enter selection mode\n            console.log(\"Heart: Entering enemy selection mode\");\n            // Return the state with heart selection mode enabled, but don't continue processing\n            return {\n              grid: newGrid,\n              powerUps: newPowerUps,\n              hqs: newHqs,\n              heartSelectionMode: true,\n              pendingHeartPlayer: currentPlayer\n            };\n          }\n        }\n      } else {\n        // Normal move - add a dot to the selected cell\n        if (newGrid[row][col].player !== currentPlayer && newGrid[row][col].player !== null) {\n          // If capturing enemy cell, replace with 1 atom\n          newGrid[row][col] = { atoms: 1, player: currentPlayer };\n        } else {\n          // Otherwise add an atom\n          newGrid[row][col].atoms += 1;\n          newGrid[row][col].player = currentPlayer;\n        }\n      }\n\n      // Queue of cells to process (for sequential chain reaction)\n      const explosionQueue: {r: number, c: number}[] = [];\n\n      // Initial check if placed cell should explode\n      if (newGrid[row][col].atoms >= getCriticalMass(row, col)) {\n        explosionQueue.push({r: row, c: col});\n      }\n\n      // Process explosions one by one (will be processed after state update)\n      if (explosionQueue.length > 0) {\n        // First state update with just the new atom placement\n        const firstState = {\n          grid: newGrid,\n          powerUps: newPowerUps,\n          hqs: newHqs\n        };\n\n        // Process explosions after a short delay (matching animation duration)\n        setTimeout(() => {\n          // Chain reaction process\n          const processExplosions = () => {\n            if (explosionQueue.length === 0) {\n              // End of chain reaction - finish turn\n              set(state => {\n                // Check for game over conditions\n                let gameOver = false;\n                let winner = null;\n\n                if (isBaseMode) {\n                  // In base mode with multiple players, check to see if only one HQ remains\n                  // Get all dead HQs\n                  const deadHQs = newHqs.filter(hq => hq.health <= 0);\n                  \n                  // Clear all dots from the board for players whose HQ was destroyed\n                  // Also remove the HQs from the array so they don't keep rendering\n                  deadHQs.forEach(deadHQ => {\n                    console.log(`Clearing all dots and removing HQ for defeated player: ${deadHQ.player}`);\n                    for (let r = 0; r < newGrid.length; r++) {\n                      for (let c = 0; c < newGrid[r].length; c++) {\n                        if (newGrid[r][c].player === deadHQ.player) {\n                          newGrid[r][c] = { atoms: 0, player: null };\n                        }\n                      }\n                    }\n                    \n                    // Remove the dead HQ from the HQs array to prevent re-rendering\n                    const hqIndex = newHqs.findIndex(hq => hq.row === deadHQ.row && hq.col === deadHQ.col && hq.player === deadHQ.player);\n                    if (hqIndex !== -1) {\n                      newHqs.splice(hqIndex, 1);\n                      console.log(`Removed HQ at (${deadHQ.row}, ${deadHQ.col}) for player ${deadHQ.player}`);\n                    }\n                  });\n                  \n                  // Get active player settings using PlayerSettingsManager\n                  let activePlayers = [PLAYER.RED, PLAYER.BLUE]; // Default\n                  \n                  try {\n                    // Get settings using the PlayerSettingsManager\n                    const settings = PlayerSettingsManager.getSettings();\n                    \n                    // Ensure we have valid players\n                    if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n                      activePlayers = settings.players;\n                      console.log(\"Using player settings for game over check:\", settings);\n                    } else {\n                      console.log(\"No valid player settings found, using defaults for game over check\");\n                    }\n                  } catch (error) {\n                    console.log(\"Error getting player settings for game over check:\", error);\n                  }\n                  \n                  // Get all surviving HQs\n                  const survivingHQs = newHqs.filter(hq => hq.health > 0);\n                  \n                  // If all HQs except one are dead, the game is over\n                  if (survivingHQs.length === 1) {\n                    gameOver = true;\n                    winner = survivingHQs[0].player;\n                  }\n                  // If no HQs remain, something weird happened!\n                  else if (survivingHQs.length === 0) {\n                    gameOver = true;\n                    winner = null; // Draw\n                  }\n                  // Alternative check: if just one HQ died this turn, the owner of that HQ loses\n                  // and the other player wins if there are only 2 players\n                  else if (deadHQs.length === 1 && activePlayers.length === 2) {\n                    gameOver = true;\n                    \n                    // Find the player who is not the one who lost\n                    const deadPlayer = deadHQs[0].player;\n                    const winnerIndex = activePlayers.findIndex(p => p !== deadPlayer);\n                    if (winnerIndex >= 0) {\n                      winner = activePlayers[winnerIndex];\n                    } else {\n                      // Fallback\n                      winner = deadPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n                    }\n                  }\n                } else {\n                  // In classic mode, game is over if only one player has atoms\n                  // AND there are at least two players who have played\n                  const playersInGame = new Set();\n                  let totalOccupiedCells = 0;\n\n                  for (let r = 0; r < state.rows; r++) {\n                    for (let c = 0; c < state.cols; c++) {\n                      if (newGrid[r][c].player) {\n                        playersInGame.add(newGrid[r][c].player);\n                        totalOccupiedCells++;\n                      }\n                    }\n                  }\n\n                  // Game is only over if:\n                  // 1. We have at least 2 moves (each player has played at least once)\n                  // 2. Only one player remains with atoms\n                  if (playersInGame.size === 1 && totalOccupiedCells > 0 && state.history.length >= 2) {\n                    gameOver = true;\n                    winner = Array.from(playersInGame)[0] as PLAYER;\n                  }\n                }\n\n                // Switch to the next player if the game isn't over\n                let nextPlayer = currentPlayer;\n                if (!gameOver) {\n                  // Get player settings using PlayerSettingsManager\n                  try {\n                    // Default to two players if anything goes wrong\n                    let activePlayers: PLAYER[] = [PLAYER.RED, PLAYER.BLUE]; \n                    \n                    // Get settings using the PlayerSettingsManager\n                    const settings = PlayerSettingsManager.getSettings();\n                    \n                    // Ensure we have valid players\n                    if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n                      activePlayers = settings.players;\n                      console.log(\"Using player settings for turn rotation:\", settings);\n                    } else {\n                      console.log(\"No valid player settings found, using defaults for turn rotation\");\n                    }\n                    \n                    // Ensure we have valid player data\n                    console.log(\"Active players for turn rotation:\", activePlayers);\n                    \n                    // Filter out dead players (in base mode)\n                    if (state.isBaseMode) {\n                      const livingHQPlayers = newHqs\n                        .filter(hq => hq.health > 0)\n                        .map(hq => hq.player);\n                        \n                      activePlayers = activePlayers.filter(player => \n                        livingHQPlayers.includes(player)\n                      );\n                      console.log(\"After filtering dead players:\", activePlayers);\n                    }\n                    \n                    // Only proceed with rotation if we have players\n                    if (activePlayers.length > 0) {\n                      // Find current player's index\n                      const currentIndex = activePlayers.indexOf(currentPlayer);\n                      console.log(\"Current player:\", currentPlayer, \"Current index:\", currentIndex);\n                      \n                      // Safety check: if current player not found in active players, use index 0\n                      const safeCurrentIndex = currentIndex === -1 ? 0 : currentIndex;\n                      \n                      // Check if players have dots on the board (skip players with no dots)\n                      // But only if they've already had their first turn (history contains them)\n                      const playersWithDots = new Set<PLAYER>();\n                      \n                      // Find all players who currently have dots on board\n                      for (let r = 0; r < newGrid.length; r++) {\n                        for (let c = 0; c < newGrid[0].length; c++) {\n                          if (newGrid[r][c].player) {\n                            playersWithDots.add(newGrid[r][c].player);\n                          }\n                        }\n                      }\n                      \n                      // Initial player rotation\n                      let nextIndex = (safeCurrentIndex + 1) % activePlayers.length;\n                      nextPlayer = activePlayers[nextIndex];\n                      \n                      // Flag to track if we've checked all players\n                      let checkedAllPlayers = false;\n                      // Counter to prevent infinite loops\n                      let safetyCounter = 0; \n                      \n                      // Check if the next player has any dots on the board\n                      // Except if it's their first turn (they should get at least one turn)\n                      while (!playersWithDots.has(nextPlayer) && state.history.length > activePlayers.length && !checkedAllPlayers && safetyCounter < activePlayers.length) {\n                        console.log(`Player ${nextPlayer} has no dots, skipping their turn`);\n                        \n                        // Move to the next player\n                        nextIndex = (nextIndex + 1) % activePlayers.length;\n                        nextPlayer = activePlayers[nextIndex];\n                        \n                        // Check if we've gone through all players \n                        if (nextIndex === ((safeCurrentIndex + 1) % activePlayers.length)) {\n                          checkedAllPlayers = true;\n                        }\n                        \n                        safetyCounter++;\n                      }\n                      \n                      // Enhanced debugging for player rotation\n                      console.log(\"PLAYER ROTATION: Current player =\", currentPlayer, \n                                  \"| Current index =\", safeCurrentIndex, \n                                  \"| Next player =\", nextPlayer, \n                                  \"| Next index =\", nextIndex,\n                                  \"| Available players =\", activePlayers,\n                                  \"| Players with dots =\", Array.from(playersWithDots));\n                    } else {\n                      // Fallback to simple 2-player rotation\n                      nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n                      console.log(\"Fallback to two players. Next player:\", nextPlayer);\n                    }\n                  } catch (error) {\n                    console.error(\"Error in player rotation logic:\", error);\n                    // Fallback to simple 2-player rotation\n                    nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n                  }\n                }\n\n                // Important: Reset the animation state when explosions are complete\n                setAnimating(false);\n                console.log(\"Animation completed - chain reaction finished\");\n\n                return {\n                  grid: newGrid,\n                  currentPlayer: nextPlayer,\n                  gameOver,\n                  winner,\n                  hqs: newHqs,\n                  powerUps: newPowerUps,\n                  animating: false // Explicitly set animating to false here as well\n                };\n              });\n              return;\n            }\n\n            // Process the next explosion in the queue\n            const {r, c} = explosionQueue.shift()!;\n            const criticalMass = getCriticalMass(r, c);\n            const cell = newGrid[r][c];\n\n            if (cell.atoms >= criticalMass) {\n              // Play explosion sound\n              if (get().animating) {\n                // Could add specific explosion sound here\n              }\n\n              // Distribute atoms to neighbors\n              newGrid[r][c].atoms -= criticalMass;\n              if (newGrid[r][c].atoms === 0) {\n                newGrid[r][c].player = null;\n              }\n\n              const neighbors = getNeighbors(r, c);\n              neighbors.forEach(({ row: nr, col: nc }) => {\n                // In base mode, check if this is an HQ cell\n                if (isBaseMode) {\n                  // Check if this is any HQ cell\n                  const isHQCell = newHqs.some(hq => hq.row === nr && hq.col === nc);\n                  \n                  if (isHQCell) {\n                    // If enemy HQ, damage it\n                    const targetHQ = newHqs.find(hq => hq.row === nr && hq.col === nc && hq.player !== currentPlayer);\n                    if (targetHQ) {\n                      // Store previous health to check if it changed\n                      const oldHealth = targetHQ.health;\n                      \n                      // Damage enemy HQ\n                      targetHQ.health -= 1;\n                      console.log(`Enemy HQ damaged! Health now: ${targetHQ.health}`);\n\n                      // Check if HQ was destroyed (health <= 0)\n                      if (targetHQ.health <= 0) {\n                        console.log(`HQ DESTROYED at (${targetHQ.row}, ${targetHQ.col})!`);\n                        \n                        // Trigger violent destruction animation\n                        set(state => ({\n                          ...state,\n                          lastHQDamaged: { \n                            row: targetHQ.row, \n                            col: targetHQ.col, \n                            player: targetHQ.player,\n                            timestamp: Date.now(),\n                            type: 'destroyed' // Mark as destruction effect\n                          }\n                        }));\n                        \n                        // Remove HQ from the list after a delay to allow animation\n                        setTimeout(() => {\n                          set(state => ({\n                            hqs: state.hqs.filter(hq => !(hq.row === targetHQ.row && hq.col === targetHQ.col))\n                          }));\n                          console.log(`HQ removed from board at (${targetHQ.row}, ${targetHQ.col})`);\n                        }, 1500); // Wait for destruction animation to complete\n                        \n                      } else {\n                        // Regular damage animation\n                        set(state => ({\n                          ...state,\n                          lastHQDamaged: { \n                            row: targetHQ.row, \n                            col: targetHQ.col, \n                            player: targetHQ.player,\n                            timestamp: Date.now(),\n                            type: 'damage'\n                          }\n                        }));\n                      }\n                    }\n                    // Skip adding atoms to any HQ cell\n                    return;\n                  }\n                }\n\n                // Regular explosion to neighboring cell\n                // Always set the cell to the current player's color\n                if (newGrid[nr][nc].player !== null && newGrid[nr][nc].player !== currentPlayer) {\n                  // Capture enemy cell - convert all atoms to current player\n                  newGrid[nr][nc].player = currentPlayer;\n                  // We now keep the current atom count and add one more \n                  // (instead of just setting to 1, which was less explosive)\n                  newGrid[nr][nc].atoms += 1;\n                } else {\n                  // Add atom to empty or own cell\n                  newGrid[nr][nc].atoms += 1;\n                  newGrid[nr][nc].player = currentPlayer;\n                }\n\n                // Check if the neighbor should explode and add to queue if it should\n                // This is critical for multi-step chain reactions\n                if (newGrid[nr][nc].atoms >= getCriticalMass(nr, nc)) {\n                  console.log(`Cell at (${nr},${nc}) will explode next (${newGrid[nr][nc].atoms}/${getCriticalMass(nr, nc)})`);\n                  // Make sure we don't have a duplicate in the queue\n                  if (!explosionQueue.some(item => item.r === nr && item.c === nc)) {\n                    explosionQueue.push({r: nr, c: nc});\n                  }\n                }\n              });\n\n              // Update grid with this explosion\n              set({ grid: [...newGrid] });\n\n              // Process next explosion after a short delay\n              setTimeout(processExplosions, 150);\n            } else {\n              // This cell doesn't need to explode, move to next\n              processExplosions();\n            }\n          };\n\n          // Start the chain reaction process\n          processExplosions();\n        }, 300); // Delay before starting chain reaction\n\n        return firstState;\n      }\n\n      // Check for game over conditions\n      let gameOver = false;\n      let winner = null;\n      \n      // If no explosions queue, we need to explicitly reset the animation state\n      // as the chain reaction logic won't run\n      if (explosionQueue.length === 0) {\n        // Reset animation state with a small delay to allow for visual feedback\n        setTimeout(() => {\n          setAnimating(false);\n          console.log(\"No chain reaction - resetting animation state\");\n        }, 100);\n      }\n\n      if (isBaseMode) {\n        // In base mode with multiple players, check to see if only one HQ remains\n        // Get all dead HQs\n        const deadHQs = newHqs.filter(hq => hq.health <= 0);\n        \n        // Get active player settings using PlayerSettingsManager\n        let activePlayers = [PLAYER.RED, PLAYER.BLUE]; // Default\n        \n        try {\n          // Get settings using the PlayerSettingsManager\n          const settings = PlayerSettingsManager.getSettings();\n          \n          // Ensure we have valid players\n          if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n            activePlayers = settings.players;\n            console.log(\"Using player settings for game over check (NO EXPLOSION):\", settings);\n          } else {\n            console.log(\"No valid player settings found, using defaults for game over check (NO EXPLOSION)\");\n          }\n        } catch (error) {\n          console.log(\"Error getting player settings for game over check (NO EXPLOSION):\", error);\n        }\n        \n        // Get all surviving HQs\n        const survivingHQs = newHqs.filter(hq => hq.health > 0);\n        \n        // If all HQs except one are dead, the game is over\n        if (survivingHQs.length === 1) {\n          gameOver = true;\n          winner = survivingHQs[0].player;\n        }\n        // If no HQs remain, something weird happened!\n        else if (survivingHQs.length === 0) {\n          gameOver = true;\n          winner = null; // Draw\n        }\n        // Alternative check: if just one HQ died this turn, the owner of that HQ loses\n        // and if there are only 2 players, the other player wins\n        else if (deadHQs.length === 1 && activePlayers.length === 2) {\n          gameOver = true;\n          \n          // Find the player who is not the one who lost\n          const deadPlayer = deadHQs[0].player;\n          const winnerIndex = activePlayers.findIndex(p => p !== deadPlayer);\n          if (winnerIndex >= 0) {\n            winner = activePlayers[winnerIndex];\n          } else {\n            // Fallback\n            winner = deadPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n          }\n        }\n      } else {\n        // In classic mode, game is over if only one player has atoms\n        // AND there are at least two players who have played\n        const playersInGame = new Set();\n        let totalOccupiedCells = 0;\n\n        for (let r = 0; r < state.rows; r++) {\n          for (let c = 0; c < state.cols; c++) {\n            if (newGrid[r][c].player) {\n              playersInGame.add(newGrid[r][c].player);\n              totalOccupiedCells++;\n            }\n          }\n        }\n\n        // Game is only over if:\n        // 1. We have at least 2 moves (each player has played at least once)\n        // 2. Only one player remains with atoms\n        if (playersInGame.size === 1 && totalOccupiedCells > 0 && state.history.length >= 2) {\n          gameOver = true;\n          winner = Array.from(playersInGame)[0] as PLAYER;\n        }\n      }\n\n      // Switch to the next player if the game isn't over\n      let nextPlayer = currentPlayer;\n      if (!gameOver) {\n        // Get player settings using PlayerSettingsManager\n        try {\n          // Default to two players if anything goes wrong\n          let activePlayers: PLAYER[] = [PLAYER.RED, PLAYER.BLUE]; \n          \n          // Get settings using the PlayerSettingsManager\n          const settings = PlayerSettingsManager.getSettings();\n          \n          // Ensure we have valid players\n          if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n            activePlayers = settings.players;\n            console.log(\"Using player settings for turn rotation (NO EXPLOSION):\", settings);\n          } else {\n            console.log(\"No valid player settings found, using defaults for turn rotation (NO EXPLOSION)\");\n          }\n          \n          // Ensure we have valid player data\n          console.log(\"Active players for turn rotation (NO EXPLOSION):\", activePlayers);\n          \n          // Filter out dead players (in base mode)\n          if (state.isBaseMode) {\n            const livingHQPlayers = newHqs\n              .filter(hq => hq.health > 0)\n              .map(hq => hq.player);\n              \n            activePlayers = activePlayers.filter(player => \n              livingHQPlayers.includes(player)\n            );\n            console.log(\"After filtering dead players (NO EXPLOSION):\", activePlayers);\n          }\n          \n          // Only proceed with rotation if we have players\n          if (activePlayers.length > 0) {\n            // Find current player's index\n            const currentIndex = activePlayers.indexOf(currentPlayer);\n            \n            // Safety check: if current player not found in active players, use index 0\n            const safeCurrentIndex = currentIndex === -1 ? 0 : currentIndex;\n            \n            // Check if players have dots on the board (skip players with no dots)\n            // But only if they've already had their first turn (history contains them)\n            const playersWithDots = new Set<PLAYER>();\n            \n            // Find all players who currently have dots on board\n            for (let r = 0; r < newGrid.length; r++) {\n              for (let c = 0; c < newGrid[0].length; c++) {\n                if (newGrid[r][c].player) {\n                  playersWithDots.add(newGrid[r][c].player);\n                }\n              }\n            }\n            \n            // Initial player rotation\n            let nextIndex = (safeCurrentIndex + 1) % activePlayers.length;\n            nextPlayer = activePlayers[nextIndex];\n            \n            // Flag to track if we've checked all players\n            let checkedAllPlayers = false;\n            // Counter to prevent infinite loops\n            let safetyCounter = 0; \n            \n            // Check if the next player has any dots on the board\n            // Except if it's their first turn (they should get at least one turn)\n            while (!playersWithDots.has(nextPlayer) && state.history.length > activePlayers.length && !checkedAllPlayers && safetyCounter < activePlayers.length) {\n              console.log(`Player ${nextPlayer} has no dots, skipping their turn`);\n              \n              // Move to the next player\n              nextIndex = (nextIndex + 1) % activePlayers.length;\n              nextPlayer = activePlayers[nextIndex];\n              \n              // Check if we've gone through all players \n              if (nextIndex === ((safeCurrentIndex + 1) % activePlayers.length)) {\n                checkedAllPlayers = true;\n              }\n              \n              safetyCounter++;\n            }\n            \n            // Enhanced debugging for player rotation\n            console.log(\"PLAYER ROTATION (NO EXPLOSION): Current player =\", currentPlayer, \n                        \"| Current index =\", safeCurrentIndex, \n                        \"| Next player =\", nextPlayer, \n                        \"| Next index =\", nextIndex,\n                        \"| Available players =\", activePlayers,\n                        \"| Players with dots =\", Array.from(playersWithDots));\n          } else {\n            // Fallback to simple 2-player rotation\n            nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n            console.log(\"Fallback to two players (NO EXPLOSION). Next player:\", nextPlayer);\n          }\n        } catch (error) {\n          console.error(\"Error in player rotation logic (NO EXPLOSION):\", error);\n          // Fallback to simple 2-player rotation\n          nextPlayer = currentPlayer === PLAYER.RED ? PLAYER.BLUE : PLAYER.RED;\n        }\n      }\n\n      // Generate only ONE power-up with a 25% chance after the first turn\n      // But don't generate if we already have too many (max 4 power-ups) - reduced spawn rate by 20%\n      if (isBaseMode && state.history.length >= 1 && Math.random() < 0.25 && newPowerUps.length < 4) {\n        console.log(\"Randomly generating ONE power-up with 25% chance\");\n        const { rows, cols } = state;\n\n        // Import isAdjacentTo utility function from gameUtils\n        const isAdjacentTo = (row1: number, col1: number, row2: number, col2: number): boolean => {\n          return Math.abs(row1 - row2) <= 1 && Math.abs(col1 - col2) <= 1;\n        };\n\n        // Never allow two power-ups at the same time - check existing power-ups and choose different type\n        const existingTypes = newPowerUps.map(p => p.type);\n        let powerUpType: PowerUpType;\n        \n        if (existingTypes.includes('diamond') && existingTypes.includes('heart')) {\n          // Both types exist, don't spawn any more\n          console.log(\"Both power-up types already exist, skipping spawn\");\n          // Skip power-up generation\n        } else {\n          if (existingTypes.includes('diamond')) {\n            // Diamond exists, only spawn heart\n            powerUpType = 'heart';\n          } else if (existingTypes.includes('heart')) {\n            // Heart exists, only spawn diamond\n            powerUpType = 'diamond';\n          } else {\n            // No power-ups exist, 50% chance of either\n            powerUpType = Math.random() < 0.5 ? 'diamond' : 'heart';\n          }\n        \n        // Find a valid position for the power-up\n        let attempts = 0;\n        let foundSpot = false;\n        \n        while (!foundSpot && attempts < 50) { // Increased attempts to find a good spot\n          const randomRow = Math.floor(Math.random() * rows);\n          const randomCol = Math.floor(Math.random() * cols);\n          \n          // Get active player settings using PlayerSettingsManager\n          let activePlayers = [PLAYER.RED, PLAYER.BLUE]; // Default\n          \n          try {\n            // Get settings using the PlayerSettingsManager\n            const settings = PlayerSettingsManager.getSettings();\n            \n            // Ensure we have valid players\n            if (settings.players && Array.isArray(settings.players) && settings.players.length > 0) {\n              activePlayers = settings.players;\n              console.log(\"Using player settings for power-up generation:\", settings);\n            } else {\n              console.log(\"No valid player settings found, using defaults for power-up generation\");\n            }\n          } catch (error) {\n            console.log(\"Error getting player settings for power-up generation:\", error);\n          }\n\n          // For more than 2 players, we don't restrict the middle rows\n          let isInMiddleRows = false;\n          \n          // Skip middle 3 rows ONLY if 2 players (for a 9x9 grid, that would be rows 3, 4, 5 - zero-indexed)\n          if (activePlayers.length <= 2) {\n            const middleRowStart = Math.floor(rows / 2) - 1;\n            const middleRowEnd = Math.floor(rows / 2) + 1;\n            isInMiddleRows = randomRow >= middleRowStart && randomRow <= middleRowEnd;\n          }\n          \n          // Check if cell is empty and not an HQ\n          const isCellEmpty = newGrid[randomRow][randomCol].player === null;\n          const isNotHQ = !newHqs.some(hq => hq.row === randomRow && hq.col === randomCol);\n          \n          // Check if not adjacent to any existing dot\n          let isAdjacentToDot = false;\n          for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < cols; c++) {\n              if (newGrid[r][c].player !== null && isAdjacentTo(randomRow, randomCol, r, c)) {\n                isAdjacentToDot = true;\n                break;\n              }\n            }\n            if (isAdjacentToDot) break;\n          }\n          \n          // Valid position if:\n          // 1. Not in middle 3 rows\n          // 2. Cell is empty\n          // 3. Not an HQ\n          // 4. Not adjacent to any existing dot\n          if (!isInMiddleRows && isCellEmpty && isNotHQ && !isAdjacentToDot) {\n            newPowerUps.push({ \n              row: randomRow, \n              col: randomCol, \n              type: powerUpType \n            });\n            console.log(`Power-up ${powerUpType} spawned at (${randomRow}, ${randomCol})`);\n            foundSpot = true;\n          }\n          \n          attempts++;\n        }\n        }\n      }\n\n      return {\n        grid: newGrid,\n        currentPlayer: nextPlayer,\n        gameOver,\n        winner,\n        hqs: newHqs,\n        powerUps: newPowerUps\n      };\n    });\n  },\n\n\n\n  // Undo the last move\n  undo: () => {\n    set(state => {\n      if (state.history.length === 0) return state;\n\n      const lastState = state.history[state.history.length - 1];\n      const newHistory = state.history.slice(0, -1);\n\n      return {\n        grid: lastState.grid,\n        currentPlayer: lastState.currentPlayer,\n        gameOver: lastState.gameOver,\n        winner: lastState.winner,\n        hqs: lastState.baseMode?.hqs || state.hqs,\n        powerUps: lastState.baseMode?.powerUps || state.powerUps,\n        history: newHistory\n      };\n    });\n  },\n\n  // Restart the current game mode\n  restart: () => {\n    const { isBaseMode } = get();\n    if (isBaseMode) {\n      get().initBaseMode();\n    } else {\n      get().initClassicMode();\n    }\n  }\n}));","size_bytes":54071},"client/src/lib/stores/useGame.tsx":{"content":"import { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\n\nexport type GamePhase = \"ready\" | \"playing\" | \"ended\";\n\ninterface GameState {\n  phase: GamePhase;\n  \n  // Actions\n  start: () => void;\n  restart: () => void;\n  end: () => void;\n}\n\nexport const useGame = create<GameState>()(\n  subscribeWithSelector((set) => ({\n    phase: \"ready\",\n    \n    start: () => {\n      set((state) => {\n        // Only transition from ready to playing\n        if (state.phase === \"ready\") {\n          return { phase: \"playing\" };\n        }\n        return {};\n      });\n    },\n    \n    restart: () => {\n      set(() => ({ phase: \"ready\" }));\n    },\n    \n    end: () => {\n      set((state) => {\n        // Only transition from playing to ended\n        if (state.phase === \"playing\") {\n          return { phase: \"ended\" };\n        }\n        return {};\n      });\n    }\n  }))\n);\n","size_bytes":893},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}","size_bytes":79},"replit.md":{"content":"# Overview\n\nChain Reaction Game is a strategic multiplayer board game built with React and TypeScript. The game features two distinct modes: Classic Mode (traditional chain reaction gameplay) and Base Reaction Mode (with headquarters and power-ups). Players take turns placing dots on a grid, and when cells reach critical mass, they explode and spread to adjacent cells, potentially creating chain reactions. The game supports both human and AI players with multiple difficulty levels.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: React 18 with TypeScript using Vite as the build tool\n- **Routing**: React Router for navigation between game modes and menu screens\n- **State Management**: Zustand for global state management with separate stores for game logic, audio, and general game state\n- **Styling**: Tailwind CSS with custom CSS variables for theming and responsive design\n- **Animation**: Framer Motion for smooth transitions and game animations\n- **UI Components**: Radix UI primitives for accessible component foundation with custom styling\n\n## Game Logic Architecture\n- **Core Game Store**: `useChainReaction` manages grid state, player turns, win conditions, and game history\n- **AI System**: Aggressive strategic AI with three difficulty levels (easy, medium, hard) focusing on:\n  - Power-up acquisition and strategic positioning\n  - Aggressive expansion and enemy territory capture\n  - Smart base defense when under attack\n  - Chain reaction maximization for massive damage\n  - Enemy base targeting for decisive victories\n- **Game Modes**: \n  - Classic Mode: Traditional chain reaction rules\n  - Base Reaction Mode: Enhanced with headquarters (HQ) system and power-ups\n- **Animation System**: Centralized animation state management with precise timing control\n- **Audio System**: Dedicated audio store for sound effects and background music management\n\n## Component Structure\n- **Game Components**: Modular game board, cells, controls, and overlay components\n- **Menu System**: Main menu with player configuration, AI settings, and tutorial screens\n- **Responsive Design**: Mobile-first approach with touch-friendly interactions\n\n## State Management Pattern\n- **Zustand Stores**: Multiple focused stores instead of single monolithic state\n- **Immutable Updates**: State updates follow immutable patterns for predictable behavior\n- **Local Storage**: Player preferences and settings persistence\n- **History System**: Undo functionality with complete game state snapshots\n\n# External Dependencies\n\n## Core Framework Dependencies\n- **React Ecosystem**: React 18, React Router for SPA navigation\n- **Build Tools**: Vite for development and production builds with TypeScript support\n- **State Management**: Zustand for lightweight, scalable state management\n\n## UI and Styling\n- **Styling**: Tailwind CSS for utility-first styling with custom configuration\n- **Component Library**: Extensive Radix UI component suite for accessible primitives\n- **Animation**: Framer Motion for performant animations and transitions\n- **Icons**: Radix UI icons and custom icon implementations\n\n## Database and Backend\n- **Database ORM**: Drizzle ORM with PostgreSQL support via Neon Database serverless driver\n- **Schema Validation**: Zod for runtime type validation and schema definition\n- **Backend Framework**: Express.js server setup (minimal implementation)\n\n## Development Tools\n- **TypeScript**: Full TypeScript implementation with strict configuration\n- **Development**: Replit-specific plugins for development environment integration\n- **Code Quality**: ESLint and TypeScript compiler checks\n\n## Deployment\n- **Static Hosting**: GitHub Pages deployment configuration\n- **Build Process**: Vite production builds with asset optimization","size_bytes":3835},"vite.config.dev.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path, { dirname } from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { fileURLToPath } from \"url\";\nimport glsl from \"vite-plugin-glsl\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    glsl(),\n  ],\n  base: \"/\",\n  server: {\n    host: \"0.0.0.0\",\n    port: 5000,\n    strictPort: true,\n    allowedHosts: true,\n    hmr: {\n      clientPort: 443,\n      protocol: 'wss'\n    }\n  },\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(__dirname, \"shared\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: \"dist\",\n    emptyOutDir: true,\n  },\n  assetsInclude: [\"**/*.gltf\", \"**/*.glb\", \"**/*.mp3\", \"**/*.ogg\", \"**/*.wav\"],\n});","size_bytes":961},"client/src/components/Game/BoardCell_broken.tsx":{"content":"import React, { useRef, useEffect, useState } from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { \n  CELL_SIZE, \n  DOT_SIZE, \n  PLAYER_COLORS, \n  ANIMATION_DURATION \n} from \"../../lib/constants\";\nimport { \n  getDotPositions, \n  calculateCriticalMass, \n  isAboutToExplode, \n  randomOffset \n} from \"../../lib/gameUtils\";\nimport type { GridCell, PowerUpType } from \"../../lib/stores/useChainReaction\";\n\ntype BoardCellProps = {\n  row: number;\n  col: number;\n  cell: GridCell;\n  totalRows: number;\n  totalCols: number;\n  onCellClick: (row: number, col: number) => void;\n  isValidMove: boolean;\n  powerUpType?: PowerUpType;\n  isHQ?: boolean;\n  hqHealth?: number;\n  maxHqHealth?: number; // Track max health to calculate damage spots\n  isHQDamaged?: boolean; // Track if this HQ cell was just damaged\n  isHQHealed?: boolean; // Track if this HQ cell was just healed\n  isHQDestroyed?: boolean; // Track if this HQ cell was just destroyed\n  heartSelectionMode?: boolean; // Track if we're in heart selection mode\n  pendingHeartPlayer?: string; // Track which player triggered the heart\n};\n\nconst BoardCell: React.FC<BoardCellProps> = ({\n  row,\n  col,\n  cell,\n  totalRows,\n  totalCols,\n  onCellClick,\n  isValidMove,\n  powerUpType,\n  isHQ,\n  hqHealth,\n  maxHqHealth = 5,\n  isHQDamaged,\n  isHQHealed,\n  isHQDestroyed,\n  heartSelectionMode = false,\n  pendingHeartPlayer\n}) => {\n  const criticalMass = calculateCriticalMass(row, col, totalRows, totalCols);\n  const aboutToExplode = isAboutToExplode(cell, row, col, totalRows, totalCols);\n  const cellRef = useRef<HTMLDivElement>(null);\n\n  // Check if this HQ is a valid heart target\n  const isHeartTarget = heartSelectionMode && isHQ && cell.player !== pendingHeartPlayer && cell.player !== null;\n\n  // Get position of dots in the cell\n  const positions = getDotPositions(cell.atoms, CELL_SIZE, DOT_SIZE);\n  \n  // Create state to hold shaking positions\n  // Initialize with one offset per atom\n  const [shakeOffsets, setShakeOffsets] = useState(() => \n    Array.from({length: cell.atoms}, () => ({x: 0, y: 0}))\n  );\n  \n  // Update the animation effect when aboutToExplode changes or atoms change\n  useEffect(() => {\n    if (aboutToExplode && cell.atoms > 0) {\n      // Use proper shaking animation for cells about to explode\n      const interval = setInterval(() => {\n        // Use more noticeable shake offsets\n        setShakeOffsets(\n          Array.from({length: cell.atoms}, () => ({\n            x: randomOffset(7), // Increased shake intensity\n            y: randomOffset(7)\n          }))\n        );\n      }, 50); // Faster interval for more visible shaking\n      \n      return () => clearInterval(interval);\n    } else {\n      // Reset offsets when not about to explode\n      setShakeOffsets(Array.from({length: cell.atoms}, () => ({x: 0, y: 0})));\n    }\n  }, [aboutToExplode, cell.atoms]);\n\n  return (\n    <div className=\"relative\" style={{ width: CELL_SIZE, height: CELL_SIZE }}>\n      {/* Background glow layer - underneath everything */}\n      {isHQ && hqHealth !== undefined && hqHealth > 0 && (\n        <div\n          className=\"absolute inset-0\"\n          style={{\n            background: isHeartTarget \n              ? \"radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 100%)\"\n              : `radial-gradient(circle, ${PLAYER_COLORS[cell.player!]}aa 0%, ${PLAYER_COLORS[cell.player!]}44 50%, transparent 100%)`,\n            borderRadius: \"4px\",\n            transform: `scale(${1 + (hqHealth * 0.3)})`, // Scale glow based on health\n            transition: \"all 0.3s ease\",\n            zIndex: 1\n          }}\n        />\n      )}\n      \n      {/* Main cell */}\n      <div\n        ref={cellRef}\n        className=\"relative\"\n        style={{\n          width: CELL_SIZE,\n          height: CELL_SIZE,\n          cursor: (isValidMove || isHeartTarget) ? \"pointer\" : \"not-allowed\",\n          backgroundColor: isHQ \n            ? `${PLAYER_COLORS[cell.player!]}66` // 40% opacity of player color for HQ\n            : \"rgba(255, 255, 255, 0.1)\", // Slightly visible white background\n          border: \"none\", // Remove border for completely flat look\n          margin: \"1px\",\n          transition: \"all 0.3s ease\", // Match the background transition speed\n          zIndex: 2\n        }}\n        onClick={() => {\n          if (isValidMove || isHeartTarget) {\n            onCellClick(row, col);\n          }\n        }}\n      >\n      {/* Power-up icon if present - completely flat with same transition speed and strong green glow */}\n      {powerUpType && cell.atoms === 0 && (\n        <div className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ \n            transition: \"all 0.3s ease\", // Match the background transition speed\n            overflow: \"visible\", // Allow glow to extend beyond boundaries\n            zIndex: 10 // Ensure glow appears on top\n          }}\n        >\n          {powerUpType === 'diamond' && (\n            <div style={{\n              filter: \"drop-shadow(0 0 12px rgb(0, 255, 0)) drop-shadow(0 0 20px rgba(0, 255, 0, 0.5))\", // Strong green glow without container clipping\n              transition: \"all 0.3s ease\"\n            }}>\n              <svg \n                width=\"26\" \n                height=\"26\" \n                viewBox=\"0 0 24 24\" \n                fill=\"rgb(50, 200, 50)\" \n                stroke=\"rgb(0, 200, 0)\" \n                strokeWidth=\"1\"\n                style={{ \n                  transition: \"all 0.3s ease\" // Match the background transition speed\n                }}\n              >\n                <path d=\"M12 2L2 12L12 22L22 12L12 2Z\" />\n              </svg>\n            </div>\n          )}\n          {powerUpType === 'heart' && (\n            <div style={{\n              filter: \"drop-shadow(0 0 12px rgb(0, 255, 0)) drop-shadow(0 0 20px rgba(0, 255, 0, 0.5))\", // Strong green glow without container clipping\n              transition: \"all 0.3s ease\"\n            }}>\n              <svg \n                width=\"26\" \n                height=\"26\" \n                viewBox=\"0 0 24 24\" \n                fill=\"rgb(50, 200, 50)\" \n                stroke=\"rgb(0, 200, 0)\" \n                strokeWidth=\"1\"\n                style={{ \n                  transition: \"all 0.3s ease\" // Match the background transition speed\n                }}\n              >\n                <path d=\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\" />\n              </svg>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* HQ base as a big circle - no drop shadows for flat design - only show if health > 0 */}\n      {isHQ && hqHealth !== undefined && hqHealth > 0 && (\n        <div className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ \n            padding: '2px' // Add padding to make space for the circle\n          }}\n        >\n          <motion.div \n            className=\"rounded-full flex items-center justify-center\"\n            initial={{ scale: 1.3 }} // Start already scaled\n            animate={(isHQDamaged || isHQHealed) ? {\n              scale: [1.3, 1.5, 1.3], // Pulse from already scaled size\n              // Removed boxShadow animation for flat design\n            } : {\n              scale: 1.3 // Keep steady size\n            }}\n            transition={{ \n              duration: 0.5,\n              ease: \"easeInOut\"\n            }}\n            style={{\n              width: '80%', \n              height: '80%',\n              backgroundColor: PLAYER_COLORS[cell.player!], // Fully opaque background\n              transition: \"all 0.8s ease\", // Match background transition speed\n              boxShadow: `0 0 ${Math.max(5, hqHealth * 6)}px ${PLAYER_COLORS[cell.player!]}${Math.floor(hqHealth / 5 * 255).toString(16).padStart(2, '0')}` // Glow based on health\n            }}\n          >\n            <span className=\"text-xl font-bold text-white\">\n              {hqHealth}\n            </span>\n          </motion.div>\n          \n          <AnimatePresence>\n            {isHQDamaged &&(\n              <>\n                {/* Electrical damage effect - black flash with cyan glow */}\n                <motion.div\n                  className=\"absolute inset-0 rounded-full\"\n                  initial={{ scale: 1, opacity: 0 }}\n                  animate={{ \n                    scale: [1.7, 1.1, 1], \n                    opacity: [0, 1, 0],\n                    backgroundColor: ['rgba(0, 0, 0, 0)', 'rgba(0, 0, 0, 0.9)', 'rgba(0, 0, 0, 0)']\n                  }}\n                  exit={{ opacity: 1 }}\n                  transition={{ duration: 0.3, times: [0, 0.5, 1] }}\n                  style={{\n                    boxShadow: '0 0 20px cyan, 0 0 40px cyan, 0 0 60px rgba(0, 255, 255, 0.5)',\n                    border: '2px solid cyan'\n                  }}\n                />\n                \n                {/* 100 gray particles exploding in all directions from whole circle */}\n                {Array.from({ length: 100 }).map((_, i) => {\n                  const angle = (i * 360) / 100 + Math.random() * 5; // Even distribution with slight randomness\n                  const distance = 50 + Math.random() * 110; // Much farther spread\n                  const size = 2 + Math.random() * 6;\n                  const grayShade = 100 + Math.random() * 100; // Different shades of gray\n                  \n                  // Start from edge of circle, not center\n                  const startRadius = 30; // Start from edge of HQ base\n                  const startX = Math.cos(angle * Math.PI / 180) * startRadius;\n                  const startY = Math.sin(angle * Math.PI / 180) * startRadius;\n                  \n                  // Final position\n                  const endX = Math.cos(angle * Math.PI / 180) * distance;\n                  const endY = Math.sin(angle * Math.PI / 180) * distance;\n                  \n                  return (\n                    <motion.div\n                      key={`damage-particle-${i}`}\n                      className=\"absolute rounded-full\"\n                      initial={{ \n                        scale: 1, \n                        opacity: 1,\n                        x: startX, // Start from edge of circle\n                        y: startY\n                      }}\n                      animate={{ \n                        scale: [1, 0.8, 0.6, 0],\n                        opacity: [1, 0.8, 0.4, 0],\n                        x: endX,\n                        y: endY\n                      }}\n                      exit={{ opacity: 1 }}\n                      transition={{ \n                        duration: 1.5,\n                        delay: 0, // All particles start at once\n                        ease: [0.15, 0.46, 0.45, 0.94] // Custom bezier for sin-like deceleration\n                      }}\n                      style={{\n                        width: size,\n                        height: size,\n                        backgroundColor: `rgb(${grayShade}, ${grayShade}, ${grayShade})`,\n                        left: '50%',\n                        top: '50%'\n                      }}\n                    />\n                  );\n                })}\n              </>\n            )}\n          </AnimatePresence>\n          \n          <AnimatePresence>\n            {isHQHealed && (\n              <>\n                {/* Only keep the healing ring effect */}\n                <motion.div\n                  className=\"absolute inset-0 rounded-full\"\n                  initial={{ scale: 0.8, opacity: 0.8 }}\n                  animate={{ scale: 1.8, opacity: 0 }}\n                  exit={{ opacity: 0 }}\n                  transition={{ duration: 0.7 }}\n                  style={{\n                    backgroundColor: 'transparent',\n                    border: `3px solid rgba(100, 255, 100, 0.8)`,\n                    boxShadow: 'none' // No shadow for flat design\n                  }}\n                />\n              </>\n            )}\n          </AnimatePresence>\n          \n          <AnimatePresence>\n            {isHQDestroyed &&(\n          <>\n            {/* Electrical damage effect - black flash with cyan glow */}\n            <motion.div\n              className=\"absolute inset-0 rounded-full\"\n              initial={{ scale: 1, opacity: 0 }}\n              animate={{ \n                scale: [1.7, 1.1, 1], \n                opacity: [0, 1, 0],\n                backgroundColor: ['rgba(0, 0, 0, 0)', 'rgba(0, 0, 0, 0.9)', 'rgba(0, 0, 0, 0)']\n              }}\n              exit={{ opacity: 1 }}\n              transition={{ duration: 0.3, times: [0, 0.5, 1] }}\n              style={{\n                boxShadow: '0 0 20px cyan, 0 0 40px cyan, 0 0 60px rgba(0, 255, 255, 0.5)',\n                border: '2px solid cyan'\n              }}\n            />\n\n            {/* 100 gray particles exploding in all directions from whole circle */}\n            {Array.from({ length: 200 }).map((_, i) => {\n              const angle = (i * 360) / 100 + Math.random() * 5; // Even distribution with slight randomness\n              const distance = 50 + Math.random() * 210; // Much farther spread\n              const size = 2 + Math.random() * 7;\n              const grayShade = 100 + Math.random() * 100; // Different shades of gray\n\n              // Start from edge of circle, not center\n              const startRadius = 30; // Start from edge of HQ base\n              const startX = Math.cos(angle * Math.PI / 180) * startRadius;\n              const startY = Math.sin(angle * Math.PI / 180) * startRadius;\n\n              // Final position\n              const endX = Math.cos(angle * Math.PI / 180) * distance;\n              const endY = Math.sin(angle * Math.PI / 180) * distance;\n\n              return (\n                <motion.div\n                  key={`damage-particle-${i}`}\n                  className=\"absolute rounded-full\"\n                  initial={{ \n                    scale: 1, \n                    opacity: 1,\n                    x: startX, // Start from edge of circle\n                    y: startY\n                  }}\n                  animate={{ \n                    scale: [1, 0.8, 0.6, 0],\n                    opacity: [1, 0.8, 0.4, 0],\n                    x: endX,\n                    y: endY\n                  }}\n                  exit={{ opacity: 1 }}\n                  transition={{ \n                    duration: 1.5,\n                    delay: 0, // All particles start at once\n                    ease: [0.15, 0.46, 0.45, 0.94] // Custom bezier for sin-like deceleration\n                  }}\n                  style={{\n                    width: size,\n                    height: size,\n                    backgroundColor: `rgb(${grayShade}, ${grayShade}, ${grayShade})`,\n                    left: '50%',\n                    top: '50%'\n                  }}\n                />\n              );\n            })}\n          </>\n          )}\n          </AnimatePresence>\n        </div>\n      )}\n\n      {/* Render atoms (except on HQ cells in base mode) */}\n      <AnimatePresence>\n        {cell.atoms > 0 && cell.player && !isHQ && (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            {positions.map((pos, index) => (\n              <motion.div\n                key={`${row}-${col}-${index}`}\n                initial={{ \n                  scale: 0,\n                  x: 0, // Start from center for smoother animation\n                  y: 0\n                }}\n                animate={{ \n                  scale: 1,\n                  x: aboutToExplode ? pos.x + shakeOffsets[index]?.x || 0 : pos.x,\n                  y: aboutToExplode ? pos.y + shakeOffsets[index]?.y || 0 : pos.y\n                }}\n                exit={{ \n                  scale: [1, 0.8, 0],\n                  x: [pos.x, pos.x * 1.5], // Move slightly outward when disappearing\n                  y: [pos.y, pos.y * 1.5]\n                }}\n                transition={{ \n                  duration: ANIMATION_DURATION / 1000,\n                  type: aboutToExplode ? \"tween\" : \"spring\",\n                  stiffness: 300,\n                  damping: 20,\n                  repeat: 0\n                }}\n                className=\"absolute rounded-full\"\n                style={{\n                  width: DOT_SIZE,\n                  height: DOT_SIZE,\n                  backgroundColor: PLAYER_COLORS[cell.player!],\n                  boxShadow: aboutToExplode \n                    ? `0 0 8px ${PLAYER_COLORS[cell.player!]}` // Strong glow effect when near critical\n                    : `0 0 2px ${PLAYER_COLORS[cell.player!]}`, // Very slight glow at all times\n                  transform: `scale(${(cell.atoms / criticalMass) * 0.7 + 0.3})` // Shrink based on critical mass ratio (min 0.3, max 1.0)\n                }}\n              />\n            ))}\n          </div>\n        )}\n      </AnimatePresence>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default BoardCell;","size_bytes":16932}}}